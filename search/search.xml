<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>specify-memory-and-cpu-of-the-container</title>
      <link href="/2019-08/specify-memory-and-cpu-of-the-container/"/>
      <url>/2019-08/specify-memory-and-cpu-of-the-container/</url>
      
        <content type="html"><![CDATA[<p>限制 Docker 容器所使用的 Memory、CPU 资源。</p><a id="more"></a><h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>Memory 的控制主要涉及的选项为 <code>memory</code> 和 <code>memory-swap</code>。这两个选项的不同组合有着不同的含义。</p><blockquote><p>注：如不特别说明，<code>memory</code> 和 <code>memory-swap</code> 均指正整数；[ a \ b ] 表示同时设置 a 和 b。</p></blockquote><h3 id="memory-memory-swap，memory-memory-swap"><a href="#memory-memory-swap，memory-memory-swap" class="headerlink" title="[ memory \ memory-swap，memory != memory-swap ]"></a>[ <code>memory</code> \ <code>memory-swap</code>，<code>memory</code> != <code>memory-swap</code> ]</h3><p><code>memory-swap</code> = <code>memory</code> + <code>swap</code><br><code>swap</code>= <code>memory-swap</code> -<code>memory</code></p><h3 id="memory-memory-swap，memory-memory-swap-1"><a href="#memory-memory-swap，memory-memory-swap-1" class="headerlink" title="[ memory \ memory-swap，memory == memory-swap ]"></a>[ <code>memory</code> \ <code>memory-swap</code>，<code>memory</code> == <code>memory-swap</code> ]</h3><p>容器将不能使用 <code>swap</code>，即 <code>swap</code> = 0。</p><h3 id="memory"><a href="#memory" class="headerlink" title="[ memory ]"></a>[ <code>memory</code> ]</h3><p><code>swap</code> = <code>memory</code> * 2</p><h3 id="memory-swap-0"><a href="#memory-swap-0" class="headerlink" title="[ memory-swap == 0 ]"></a>[ <code>memory-swap</code> == 0 ]</h3><p><code>memory-swap</code> 的设置将被忽略，相当是没有设置 <code>memory-swap</code>。</p><h3 id="memory-swap-1"><a href="#memory-swap-1" class="headerlink" title="[ memory-swap == -1 ]"></a>[ <code>memory-swap</code> == -1 ]</h3><p>容器的 <code>swap</code> 和宿主机的 <code>swap</code> 大小一样。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>不能直接在容器内部执行相关的查看命令（如 <code>free</code>）查看容器内存的“限制”信息，这类命令（如 <code>free</code>）在容器中得到数据是和宿主机上的数据是一样的。<br>可以使用 <code>docker stats container</code> 或者 <code>docker inspect</code> 查看容器的资源“限制”信息。</p><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>CPU 的控制（数量）主要涉及的选项为 <code>cpu-period</code> 和 <code>cpu-quota</code>，如果是 Docker 1.13 及以上，可以用更方便的 <code>cpus</code> 取代。另外还有 <code>cpuset-cpus</code> 用于指定容器进程使用哪个 CPU，有点类似于 <code>taskset</code>。</p><blockquote><p>注意：这里的 CPU，指的是逻辑 CPU。</p></blockquote><h3 id="cpu-period、cpu-quota"><a href="#cpu-period、cpu-quota" class="headerlink" title="cpu-period、cpu-quota"></a><code>cpu-period</code>、<code>cpu-quota</code></h3><blockquote><p><code>cpu-period</code>：The length of a CPU period in microseconds.<br><code>cpu-quota</code>：Microseconds of CPU time that the container can get in a CPU period.  </p></blockquote><p><code>cpu-period</code> 的默认值为 <code>100</code> 毫秒（<code>cpu-period</code> 给的是 <code>100000</code>，应该是换算为微秒了），没什么特别需求不用更改。</p><p>实际 CPU 的使用量为 <code>cpu-quota/cpu-period</code>，<code>cpu-quota</code> 使用默认值 <code>100000</code>。  </p><p>如果限制为一个 CPU 的 50%（半个 CPU），<code>cpu-quota</code> 则为 <code>50000</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 更多例子</span><br><span class="line">cpu-period = 100000</span><br><span class="line">cpu-quota = 100000</span><br><span class="line">1 个 CPU。</span><br><span class="line"></span><br><span class="line">cpu-period = 100000</span><br><span class="line">cpu-quota = 150000</span><br><span class="line">1.5 个 CPU。</span><br><span class="line"></span><br><span class="line">cpu-period = 100000</span><br><span class="line">cpu-quota = 200000</span><br><span class="line">2 CPU。</span><br></pre></td></tr></table></figure><h3 id="cpus"><a href="#cpus" class="headerlink" title="cpus"></a><code>cpus</code></h3><blockquote><p><code>cpus</code>：Number of CPUs.</p></blockquote><p>虽然 <code>cpus</code> 可以很方便地达到和 <code>cpu-period</code>、<code>cpu-quota</code> 基本“一样”的效果，但是 <code>cpus</code> 并不是在内部（Docker Engine API 层）转换为 <code>cpu-period</code>、<code>cpu-quota</code>。<code>cpus</code> 选项实际上设置的是 API 里面的 <code>NanoCPUs</code>。</p><blockquote><p><code>NanoCPUs</code>：CPU quota in units of 1e-9 CPUs.</p></blockquote><p>1 cpus = 1000000000 NanoCPUs</p><h3 id="cpuset-cpus"><a href="#cpuset-cpus" class="headerlink" title="cpuset-cpus"></a><code>cpuset-cpus</code></h3><blockquote><p><code>cpuset-cpus</code>：CPUs in which to allow execution (0-3, 0,1).</p></blockquote><p><code>cpuset-cpus</code> 的优先级要比 <code>cpu-quota</code>、<code>cpu-period</code> 和 <code>cpus</code> 高。<br><code>cpuset-cpus</code> 为 <code>0-3</code> 表示容器进程可以运行在 0 到 3 号 CPU 上，<code>0,1</code> 表示容器进程可以运行在 0 和 1 号 CPU 上。<br>如果 <code>cpuset-cpus</code> 为 0，则表示容器进程只可以运行在 0 号 CPU 上。</p><p><code>cpu-quota/cpu-period</code> 或 <code>cpus</code> 的“有效值”永远是小于或者等于 <code>cpuset-cpus</code> 所涉及到的 CPU 数量。<br>即是说，当 <code>cpu-quota/cpu-period</code> 或 <code>cpus</code> 的值为 2 时，如果 <code>cpuset-cpus</code> 所涉及到的 CPU 数量只有一个，如 0 号 CPU。那么容器最多只能使用 0 号 CPU 100% 的资源（一个 CPU）。</p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>如果是使用 <code>cpus</code> 限制容器的 CPU 数量，当指定的数量大于宿主机的 CPU 数量时，会返回不能指定大于宿主机的 CPU 数量的提示。<br>而用 <code>cpu-quota</code> 和 <code>cpu-period</code> 时，当他们的比值大于宿主机的 CPU 数量时，是不会报错的。因为 <code>cpu-quota</code> 指定的是“上限配额”，如果 <code>cpu-quota/cpu-period</code> 大于宿主机的 CPU 数量时，则是表示可以使用所有的 CPU 资源。</p><blockquote><p>注：关于 cpu-period 和 cpu-quota 更详细的信息，请看参考。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://docs.docker.com/config/containers/resource_constraints/" target="_blank" rel="noopener">https://docs.docker.com/config/containers/resource_constraints/</a></li><li><a href="https://docker-py.readthedocs.io/en/4.0.2/containers.html" target="_blank" rel="noopener">https://docker-py.readthedocs.io/en/4.0.2/containers.html</a></li><li><a href="https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Resource </tag>
            
            <tag> CPU </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vs-code-remote-development</title>
      <link href="/2019-07/vs-code-remote-development/"/>
      <url>/2019-07/vs-code-remote-development/</url>
      
        <content type="html"><![CDATA[<p>使用 VS Code 的远程开发功能。</p><a id="more"></a><p>之前 VS Code 的远程功能其实很弱，在这个“强化”后的功能正式推出时，就立即尝试了下，不过直到最近才算正式的在自己的日常开发中使用起来</p><p>对于大多数的程度开发、服务软件通常在 Linux 上面都有有更好的支持（不包括 Windows、MacOS 之类平台的程序等）。所以个人的开发环境基本是在 Linux 上面的。</p><p>此前、包括现在，我用最多的的编辑器是 Vim ，其次是 VS Code。VS Code 的功能基本上都能在 Vim 找到相应的插件。不过 Vim 对于一些自动补全、代码跟踪等复杂一点的插件，其安装通常比较繁琐的，也很可能为了打开某个支持，需要重新编译 vim。我的使用软件的“原则”是尽可能的做到简易、且易于迁移。</p><p>所以，上面说的那类 Vim 的插件我基本是不使用的。</p><p>对于一些“规模”点的项目，就会感觉到 Vim 的短板了（如果你愿意，基本都能强化）。在此情况下，我选择了更为现代化、且易于配置的的编辑器 VS Code。</p><h2 id="VS-Code-的远程开发配置"><a href="#VS-Code-的远程开发配置" class="headerlink" title="VS Code 的远程开发配置"></a>VS Code 的远程开发配置</h2><p>VS Code 的远程开发支持三个模式，WSL、SSH（远程主机）、Containers（Docker 容器）。</p><h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><ol><li>首先是需要在 Windows 上安装 OpenSSH 程序（略过）</li><li>下载 VS Code 的远程开发插件 <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpackRemote Development" target="_blank" rel="noopener">Remote Development</a></li></ol><blockquote><p>这个插件是个插件组，包含了上面三个模式及其他功能所需要的插件，原理上说可以只下自己需要的那几个</p></blockquote><!-- <img id="sm" src="/2018-09/wsl-frp-web/set.png"> --><p><img id="sm" src="/2019-07/vs-code-remote-development/2019-07-25-remote-dev.jpg">▲ Remote Development 插件组</p><h2 id="VS-Code-远程主机配置"><a href="#VS-Code-远程主机配置" class="headerlink" title="VS Code 远程主机配置"></a>VS Code 远程主机配置</h2><p>配置文件中的 Host 为远程主机名，在 VS Code 中起的是标识主机的作用。</p><img src="/2019-07/vs-code-remote-development/2019-07-25-remote-conf.jpg"><p>▲ 远程主机配置</p><p>接着连接远程主机，后期可以用密钥对进行验证，那样就不会输入密码了。如果是初次连接，会在远程主机安装 VS Code 的服务程序。其安装路径为 <code>~/.vscode-server/</code>，VS Code 的远程插件也是安装在这个路径下。</p><img src="/2019-07/vs-code-remote-development/2019-07-25-connent.jpg"><p>▲ 连接远程主机</p><p>连接成功后，选择项目的路径，打开项目文件。</p><img src="/2019-07/vs-code-remote-development/2019-07-25-complete.jpg"><p>▲ 打开远程项目</p><h2 id="关于远程插件"><a href="#关于远程插件" class="headerlink" title="关于远程插件"></a>关于远程插件</h2><p>VS code 可以将插件安装在本地，即宿主机上，也可以将插件安装在远程主机上。需要注意的事，与开发环境相关的插件，要安装在与项目同一个主机上。即是说，远程的项目，用的是远程主机的环境，就得将插件安装在远程主机上。</p><p>此前，我就遇到一个情况，打开远程项目（在远程的 Linux 主机）后，然后在项目中进行代码的跟踪，在查看跟踪到的代码文件的路径时，发现是 Windows 上的（我的宿主机是 Windows）。对于这情况显然不是我所希望的。后面排查到是插件的问题。正确、合理的方法的，将相应的开发环境的插件，安装在项目所在的主机上。</p><p>PS: 后来我想复现一下上面情况结果不行了，是我弄混了还是我的错觉…</p><h2 id="django-和-Vue-Debug-的基本配置"><a href="#django-和-Vue-Debug-的基本配置" class="headerlink" title="django 和 Vue Debug 的基本配置"></a>django 和 Vue Debug 的基本配置</h2><p>连接远程主机，并分别创建 django 和 Vue 的项目。</p><img src="/2019-07/vs-code-remote-development/2019-07-26-dev-create.jpg"><p>▲ 创建测试项目</p><h3 id="django"><a href="#django" class="headerlink" title="django"></a>django</h3><img src="/2019-07/vs-code-remote-development/2019-07-26-debug-django.jpg"><p>▲ 创建 django 类型的 Debug 配置</p><blockquote><p>.vscode/launch.json</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">"configurations": [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Python: Django"</span>,</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"python"</span>,</span><br><span class="line">        <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">        <span class="attr">"program"</span>: <span class="string">"$&#123;workspaceFolder&#125;/manage.py"</span>,</span><br><span class="line">        <span class="attr">"args"</span>: [</span><br><span class="line">            <span class="string">"runserver"</span>,</span><br><span class="line">            <span class="string">"--noreload"</span>,</span><br><span class="line">            <span class="string">"0:8000"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"django"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"console"</span>: <span class="string">"integratedTerminal"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>--noreload</code> 选项需要留住，不然在 Shift+F5 停止 Debug 后，django 的服务是不会自己停止的，在下次启动 Debug 时就会失败。</p><h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><img src="/2019-07/vs-code-remote-development/2019-07-26-debug-npm.jpg"><p>▲ 创建用于 vue 的 Node.js npm 类型的 Debug 配置</p><blockquote><p>.vscode/launch.json</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">"configurations": [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"node"</span>,</span><br><span class="line">        <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Launch via NPM"</span>,</span><br><span class="line">        <span class="attr">"runtimeExecutable"</span>: <span class="string">"npm"</span>,</span><br><span class="line">        <span class="attr">"runtimeArgs"</span>: [</span><br><span class="line">            <span class="string">"run-script"</span>,</span><br><span class="line">            <span class="string">"serve"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"console"</span>: <span class="string">"integratedTerminal"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>根据实际情况修改配置。另外，要加上 <code>&quot;console&quot;: &quot;integratedTerminal&quot;</code>，使用可以交互的终端类型，不然可能会“卡死”。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://code.visualstudio.com/docs/remote/remote-overview" target="_blank" rel="noopener">https://code.visualstudio.com/docs/remote/remote-overview</a></p>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
            <tag> Linux </tag>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-cli-3-use-webpack-devserver-proxy-to-solve-cors</title>
      <link href="/2019-07/vue-cli-3-use-webpack-devserver-proxy-to-solve-cors/"/>
      <url>/2019-07/vue-cli-3-use-webpack-devserver-proxy-to-solve-cors/</url>
      
        <content type="html"><![CDATA[<p>使用 Vue Cli 配置 webpack devServer 代理，解决跨域问题。</p><a id="more"></a><p>对于开发、测试期间，解决跨域问题有几个比较方便方法。</p><ul><li>配置浏览器，添加浏览器的启动选项 <code>--disable-web-security --user-data-dir</code> 使其允许跨域</li><li>配置相关的开发工具，如 webpack devServer</li></ul><p>如果使用 Vue Cli 3.x，配置和之前的版本有些区别。其配置文件为项目 root 目录下的 <code>vue.config.js</code>，可以直接在 Vue Cli 的配置文件中对 webpack devServer 进行配置，Vue Cli 最终会将这部分配置应用到 webpack devServer。除此，原理上说，也可以直接使用 webpack 的配置文件 <code>webpack.config.js</code> 对 webpack devServer 进行配置。不过为了统一性，这里是在 Vue Cli 的配置文件进行配置。</p><blockquote><p>vue.config.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">'/api'</span>: &#123;</span><br><span class="line">                target:<span class="string">'http://api.com:8000'</span>,</span><br><span class="line">                changeOrigin: <span class="literal">true</span>,</span><br><span class="line">                pathRewrite: &#123;<span class="string">'^/api'</span> : <span class="string">''</span>&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果为 <code>http://localhost/api/abc =&gt; http://api.com:8000/abc</code></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://cli.vuejs.org/zh/config/#devserver-proxy" target="_blank" rel="noopener">https://cli.vuejs.org/zh/config/#devserver-proxy</a></li><li><a href="https://www.webpackjs.com/configuration/dev-server/#devserver-proxy" target="_blank" rel="noopener">https://www.webpackjs.com/configuration/dev-server/#devserver-proxy</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> webpack </tag>
            
            <tag> CORS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>update-html-syntax-indentation-on-vim7</title>
      <link href="/2019-06/update-html-syntax-indentation-on-vim7/"/>
      <url>/2019-06/update-html-syntax-indentation-on-vim7/</url>
      
        <content type="html"><![CDATA[<p>更新 vim7 的 html 语法缩进脚本。</p><a id="more"></a><p>同样是执行 <code>gg=G</code> 对 html 文件进行语法的格式化（缩进），不过在 <code>centos7</code> 上面的 vim7.x 并没有按预期那样工作。接而安装了一个 vim8.1.x 进行比对测试，结果是 vim8.1.x 可以对 html 进行合理的语法格式化。</p><img src="/2019-06/update-html-syntax-indentation-on-vim7/20190607_vim7_html_indent.png"><p>▲ vim7.x</p><img src="/2019-06/update-html-syntax-indentation-on-vim7/20190607_vim81_html_indent.png"><p>▲ vim8.1.x</p><p>排查出是因为 vim7.x runtime 里面 html.vim indent 语法缩进脚本版本过旧。解决方法是将 vim8.1 的 html.vim indent 语法缩进脚本复制到 vim7.x runtime 的 indent 目录。可以通过 <code>:echo $VIMRUNTIME</code> 查看 runtime 目录的路径。或者是复制到 <code>~/.vim/indent/</code>，比较推荐复制到家目录下。</p><p>关于 indent 脚本的获取。在 <a href="https://www.vim.org/" target="_blank" rel="noopener">vim 的官网</a>上的 vim 脚本版本基本是 vim7 时代的，并不新。</p><img src="/2019-06/update-html-syntax-indentation-on-vim7/20190607_html_indent.png"><p>▲ 从上至下分别是 vim 官网、vim7.x 、vim8.1x 的 html.vim</p><p>较新的 vim 脚本可以到 <a href="https://github.com/vim/vim" target="_blank" rel="noopener">vim 的 github</a> 源码里下载。另外不推荐直接将整个 runtime 替换更新，没测试过，或许有不兼容。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
            <tag> HTML </tag>
            
            <tag> syntax </tag>
            
            <tag> indent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>use-xterm-js-attach-to-docker-container</title>
      <link href="/2019-05/use-xterm-js-attach-to-docker-container/"/>
      <url>/2019-05/use-xterm-js-attach-to-docker-container/</url>
      
        <content type="html"><![CDATA[<p>使用 <code>xterm.js</code> “attach” 到 docker 的容器。</p><a id="more"></a><h1 id="xterm-js"><a href="#xterm-js" class="headerlink" title="xterm.js"></a>xterm.js</h1><p><code>xterm.js</code> 是一个前端组件，可以在中浏览器提供功能齐全的“终端”。只要，使用相关插件和提供相关功能的后端模块，就可以使用 <code>xterm.js</code> 在 web 中接入到 linux，除此，还能够接入到 docker 的容器。</p><p>xterm.js 已经“自带”了相关的后端和插件，如 <code>Terminado</code>，如果需要也可以自己开发一个。</p><h2 id="xterm-js-插件"><a href="#xterm-js-插件" class="headerlink" title="xterm.js 插件"></a>xterm.js 插件</h2><ul><li>attach：用于 attach 到 docker 容器</li><li>fit：自适应，指终端的窗口自适应，内容自动调整</li><li>fullscreen：全屏</li><li>terminado：用于和 xterm.js 的后端 Terminado 一起使用</li></ul><h1 id="使用-xterm-js-接入-linux"><a href="#使用-xterm-js-接入-linux" class="headerlink" title="使用 xterm.js 接入 linux"></a>使用 xterm.js 接入 linux</h1><p>xterm.js 官网给了两个使用 Terminado 的例子，主要的区别是关于 xterm.js 的引用方式，这部分可以使用传统的方式直接引用 xterm.js 的 js 文件，也可以使用 ES6 的语法，引用相关模块，再“编译”。实际上 xterm.js 首推的是使用 ES6 的语法，不过这个例子我是直接引用预先“编译”好的 js 文件。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>首先新建一个项目，下载、安装 xterm.js 和 Terminado。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save xterm</span><br><span class="line">pip install terminado</span><br></pre></td></tr></table></figure><p>然后将 xterm.js 预先“编译”好的目标文件 <code>./node_modules/xterm/dist/</code> 复制到项目 root 目录。</p><p>接着在项目 root 目录下添加一个后端文件 <code>app.py</code> 和一个前端文件 <code>index.html</code>。</p><p><strong>app.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/usr/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"><span class="keyword">from</span> terminado <span class="keyword">import</span> TermSocket, SingleTermManager</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    term_manager = SingleTermManager(shell_command=[<span class="string">'bash'</span>])</span><br><span class="line">    handlers = [</span><br><span class="line">                (<span class="string">r"/websocket"</span>, TermSocket, &#123;<span class="string">'term_manager'</span>: term_manager&#125;),</span><br><span class="line">                (<span class="string">r"/()"</span>, tornado.web.StaticFileHandler, &#123;<span class="string">'path'</span>:<span class="string">'index.html'</span>&#125;),</span><br><span class="line">                (<span class="string">r"/(.*)"</span>, tornado.web.StaticFileHandler, &#123;<span class="string">'path'</span>:<span class="string">'.'</span>&#125;),</span><br><span class="line">               ]</span><br><span class="line">    app = tornado.web.Application(handlers)</span><br><span class="line">    app.listen(<span class="number">8010</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p><strong>index.html</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/dist/xterm.css"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/dist/xterm.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/dist/addons/terminado/terminado.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"terminal-container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">      terminado.apply(Terminal);</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> term = <span class="keyword">new</span> Terminal(),</span></span><br><span class="line"><span class="javascript">          protocol = (location.protocol === <span class="string">'https:'</span>) ? <span class="string">'wss://'</span> : <span class="string">'ws://'</span>,</span></span><br><span class="line"><span class="javascript">          socketURL = protocol + location.hostname + ((location.port) ? (<span class="string">':'</span> + location.port) : <span class="string">''</span>) + <span class="string">"/websocket"</span>;</span></span><br><span class="line"><span class="javascript">          sock = <span class="keyword">new</span> WebSocket(socketURL);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      sock.addEventListener(<span class="string">'open'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">        term.terminadoAttach(sock);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">      term.open(<span class="built_in">document</span>.getElementById(<span class="string">'terminal-container'</span>));</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>最后运行 <code>app.py</code>。</p><img src="/2019-05/use-xterm-js-attach-to-docker-container/2019-05-09_xterm_ado.jpg"><p>▲ xterm.js 接入 linux 效果</p><p>项目的关键文件为 <code>app.py</code>、<code>index.html</code> 及已经预先“编译”好的 xterm.js 目标 js 文件 <code>dist/</code></p><h1 id="使用-xterm-js-attach-到-docker-容器"><a href="#使用-xterm-js-attach-到-docker-容器" class="headerlink" title="使用 xterm.js attach 到 docker 容器"></a>使用 xterm.js attach 到 docker 容器</h1><p>这部分使用 ES6 的方式引用 xterm.js，实际尝试过直接引用预先“编译”好的 js 文件，不过并没能成功，而官网也没“传统”引用方法的示例（这部分），所以还是直接选择“避坑”吧…</p><h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h2><p>同样的新建一个项目，因为浏览器目前对 ES6 并不能 100% 支持，所以需要下载 <code>webpack</code>、<code>webpack-cli</code>、<code>webpack-dev-server</code>，用于打包（编译）、调试 js。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack webpack-cli webpack-dev-server</span><br></pre></td></tr></table></figure><p>接着下载 xterm.js。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save xterm</span><br></pre></td></tr></table></figure><img src="/2019-05/use-xterm-js-attach-to-docker-container/2019-05-09_xterm_attach_pack.jpg"><p>▲ 项目包含的包（package.json）</p><h3 id="配置-package-json-和-webpack"><a href="#配置-package-json-和-webpack" class="headerlink" title="配置 package.json 和 webpack"></a>配置 package.json 和 webpack</h3><p><strong>package.json</strong></p><p>配置 npm 脚本，修改根目录下的 <code>package.json</code> ，在 <code>scripts</code> 添加如下内容。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">        <span class="attr">"dev"</span>: <span class="string">"webpack-dev-server"</span>,</span><br><span class="line">        <span class="attr">"build"</span>: <span class="string">"webpack --progress --mode=development"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>webpack.config.js</strong></p><p>配置 webpack，在项目根目录下修改 webpack.config.js 文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'dist/bundle.js'</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'./'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        contentBase: path.join(__dirname, <span class="string">"./"</span>),</span><br><span class="line">        compress: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>注意：<br><code>output</code> 里的 <code>path</code> 为打包后的目标文件的路径，<code>devServer</code> 里的 <code>contentBase</code> 为 webpack-dev-Server 指定的 web root 目录，这两个需要一样，不然“热更新”可能无效。</p></blockquote><p>开发环境配置好后，就可以进入主题了。</p><p>根据前面 <code>webpack.config.js</code> 的配置，在项目根目录下新建入口文件 <code>./src/index.js</code>。</p><p><strong>./src/index.js</strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Terminal&#125; <span class="keyword">from</span> <span class="string">'xterm'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> attach <span class="keyword">from</span> <span class="string">'xterm/lib/addons/attach/attach'</span>;</span><br><span class="line"></span><br><span class="line">Terminal.applyAddon(attach);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> term = <span class="keyword">new</span> Terminal();</span><br><span class="line">term.open(<span class="built_in">document</span>.getElementById(<span class="string">'#terminal'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ws_host = <span class="string">"192.168.0.4:2375"</span>;</span><br><span class="line"><span class="keyword">var</span> container = <span class="string">"test"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ws = <span class="string">"ws://"</span> + ws_host + <span class="string">"/containers/"</span> + container + <span class="string">"/attach/ws?stream=true"</span>;</span><br><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(ws);</span><br><span class="line"></span><br><span class="line">term.attach(socket);</span><br></pre></td></tr></table></figure><p>ws 的 URL，实际是 docker engine 的 API，需要注意的是，需要将 <code>stream</code> 设置为 <code>true</code>，不然即使连接上，也是无法传递数据的。</p><img src="/2019-05/use-xterm-js-attach-to-docker-container/2019-05-09_docker_ws_api.jpg"><p>▲ docker websocket API</p><p>接着在项目 root 目录下新建 index.html。</p><p><strong>index.html</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"node_modules/xterm/dist/xterm.css"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/xterm/dist/xterm.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hey!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"terminal"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"dist/bundle.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>到这里，所有的关键代码已经准备好了。</p><img src="/2019-05/use-xterm-js-attach-to-docker-container/2019-05-09_xterm_attach_tree.jpg"><p>▲ 项目目录结构</p><h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><p>首先运行一个容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name <span class="built_in">test</span> -itd ubuntu:latest bash</span><br></pre></td></tr></table></figure><p>在项目 root 目录执行 <code>npm run dev</code>，进行调试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><img src="/2019-05/use-xterm-js-attach-to-docker-container/2019-05-09_xterm_attach.jpg"><p>▲ xterm.js 接入 docker 容器效果</p><h1 id="关于-xterm-js-attach-到容器"><a href="#关于-xterm-js-attach-到容器" class="headerlink" title="关于 xterm.js attach 到容器"></a>关于 xterm.js attach 到容器</h1><p>docker engine 的 API 里面提供了两个 attach 到容器的方法。一个是和其他 API 一样使用 HTTP 协议的 attach，另一个为使用 websocket 协议的 attach。</p><p>在上面的说明（docker api的截图）中可以看到，docker engine 的 API 里面并没有对 websocket 有过多的解释。实际上，websocket 协议的 attach 和 HTTP 协议的 attche在“原理”上是一样的，只是他们的数据的传输方式不一样。</p><h2 id="docker-attach"><a href="#docker-attach" class="headerlink" title="docker attach"></a>docker attach</h2><img src="/2019-05/use-xterm-js-attach-to-docker-container/2019-05-09_docker_attach.jpg"><p>▲ docker attach 的解释</p><p>实际是 docker attach 是 “attach” 到容器创建时的 <code>ENTRYPOINT/CMD</code> 命令的进程（默认指PID 1进程）。如果在容器创建时通过 <code>-i</code> 让容器保持打开 <code>stdin</code>，“attach” 到容器后将可以与容器进行“交互”（如果条件合适）。</p><h3 id="关于-i"><a href="#关于-i" class="headerlink" title="关于 -i"></a>关于 <code>-i</code></h3><p><em>Keep STDIN open even if not attached.</em></p><p><code>-i</code> 有两个作用；一、是会让容器保持stdin开放，二是、同时也会 attach 到容器的 stdin（即使通过 <code>-a</code> 指定 attach 到 stdxx）。</p><blockquote><p>注：<code>-t</code>是给容器分配一个虚拟终端，也是关键。</p></blockquote><p>docker create 或 exec 指定的 commond 会通过 stdin （这里应该是 API -&gt; docker engine -&gt; container，不过我简略了）在容器内执行，执行这“一次”结束后容器，将会关闭“此次”的 stdin；如果是使用 <code>-i</code>，将会保持stdin打开；要是commond进程可以交互，用户则可以输入命令，命令将继续通过开放stdin在容器内执行。</p><p>如上所述，attach 最终能不能交互还得看<code>ENTRYPOINT/CMD</code> 命令的进程自身有没有“交互”的功能，比如可以交互的有 <code>bash</code>、<code>top</code>，不能交互的有 <code>ls</code>等。</p><h2 id="xterm-js-attach-的局限"><a href="#xterm-js-attach-的局限" class="headerlink" title="xterm.js attach 的局限"></a>xterm.js attach 的局限</h2><p>到这里可以得出结论，xterm.js attach 到容器，最终能不能进行交互，和容器的 <code>ENTRYPOINT/CMD</code> 的命令有很大的关系。如果在创建容器时没指定 <code>-it</code> 或者 <code>ENTRYPOINT/CMD</code> 不是 <code>bash</code> 之类的可交互进程，xterm.js 虽然可以连接到容器，但都不可以与容器进行交互的。</p><p>而实际情况是，绝大多数的容器事务，这两个条件都没有。</p><h2 id="xterm-js-连接到容器的解决方案"><a href="#xterm-js-连接到容器的解决方案" class="headerlink" title="xterm.js 连接到容器的解决方案"></a>xterm.js 连接到容器的解决方案</h2><p>使用 <code>exec</code>。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://xtermjs.org/docs/" target="_blank" rel="noopener">https://xtermjs.org/docs/</a></li><li><a href="https://docs.docker.com/engine/api/v1.39/#operation/ContainerAttachWebsocket" target="_blank" rel="noopener">https://docs.docker.com/engine/api/v1.39/#operation/ContainerAttachWebsocket</a></li><li><a href="https://docs.docker.com/engine/reference/commandline/attach/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/attach/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> xterm.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>directly-use-docker-s-unix-socket-type-api</title>
      <link href="/2019-04/directly-use-docker-s-unix-socket-type-api/"/>
      <url>/2019-04/directly-use-docker-s-unix-socket-type-api/</url>
      
        <content type="html"><![CDATA[<p>直接使用 docker 的 unix-socket 类型 API。</p><a id="more"></a><h2 id="Docker-engine-API-说明-1"><a href="#Docker-engine-API-说明-1" class="headerlink" title="Docker engine API 说明 [1]"></a>Docker engine API 说明 [<a href="https://docs.docker.com/engine/reference/commandline/dockerd/" target="_blank" rel="noopener">1</a>]</h2><p>docker engine有三种类型的API。</p><ol><li>unix (socket)</li><li>tcp (socket)</li><li>fd (Systemd socket)</li></ol><p><strong>注意：</strong></p><p>fd 的 socket 文件默认也是绑定在本地的 <code>/var/run/docker.sock</code>，这个和 unix-sock 的 socket 文件路径一样，而且 fd 和 unix socket 在访问上“好像”并没什么区别，更多特性上细节上的还待考究。</p><p>下面是 docker engine 的部分 systemd 的启动脚本，更多请参阅<a href="https://github.com/moby/moby/blob/master/contrib/init/systemd/docker.socket" target="_blank" rel="noopener">github moby</a>。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=Docker Socket for the API</span><br><span class="line"><span class="attr">PartOf</span>=docker.service</span><br><span class="line"></span><br><span class="line"><span class="section">[Socket]</span></span><br><span class="line"><span class="attr">ListenStream</span>=/var/run/docker.sock</span><br><span class="line"><span class="attr">SocketMode</span>=<span class="number">0660</span></span><br><span class="line"><span class="attr">SocketUser</span>=root</span><br><span class="line"><span class="attr">SocketGroup</span>=docker</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=sockets.target</span><br></pre></td></tr></table></figure><p>因为主机是 CentOS ，使用的是 systemd，后面所说的 unix-socket 实际上是 fd ，不过我在API操作上并没有感觉到有什么不同，所以就统一称为 unix-socket。</p><p>通常情况下，接触最多的应该是 docker engine 的 TCP 类型的 API 了，也就是通过 <code>Host:Port</code> 的形式访问 API。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://<span class="variable">$HOST</span>:2375/info</span><br></pre></td></tr></table></figure><p>除此 docker engine 还有 unix-socket 类型的 API，docker-cli 默认就是通过这个 API 访问 docker engine。我们也可以直接使用 unix-socket 类型的 API。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --unix-socket /var/run/docker.sock http:/info</span><br></pre></td></tr></table></figure><p>相比之下，TCP 类型的 API 要比 unix-socket 类型的 API 更容易使用。对于 unix-socket 类型，需要自己构造 HTTP 协议的报文等；而 TCP 类型的 API 已经帮我们处理了很多细节上的东西。但是，如果是开发，首选的应该是使用 unix-socket 类型的 API。</p><p>关于 docker 开发，docker 官方已经提供了 go 和 pyton 的 SDK，除此还有很多非官方版本的 SDK，如 C、java 等。使用 SDK，可以让开发更加的快捷，便利。如果想定制自己的 “SDK” 或只是想利用其中的一部分 API，则可以针对 docker engine 的 API 自己独立进行开发，这也是文章的主题。</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>Docker engine 提供的是 HTTP （协议）的 API，要使用 docker engine unix-socket 类型的 API，需要对以下知识有一定的了解。</p><ul><li>unix-socket</li><li>HTTP Protocol</li></ul><h2 id="unix-socket"><a href="#unix-socket" class="headerlink" title="unix-socket"></a>unix-socket</h2><p><code>socket</code> 用于网络编程，可以使不同的的机器进行通信，这类（TCP socket）需要绑定一个主机的 IP 及 Port。</p><blockquote><p>unix - sockets for local interprocess communication.</p></blockquote><p>unix-socket 用于本地进程间的通信， TCP socket 也可以通过绑定本地IP，<code>127.0.0.1</code> 实现“本地”进程间的通信，不过 unix-socket 的效率会更高。</p><h2 id="HTTP-Protocol-2"><a href="#HTTP-Protocol-2" class="headerlink" title="HTTP Protocol [2]"></a>HTTP Protocol [<a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="noopener">2</a>]</h2><h3 id="HTTP-报文结构"><a href="#HTTP-报文结构" class="headerlink" title="HTTP 报文结构"></a>HTTP 报文结构</h3><img src="/2019-04/directly-use-docker-s-unix-socket-type-api/20190426_http_message.jpg"><p>▲ HTTP（通用）报文结构</p><img src="/2019-04/directly-use-docker-s-unix-socket-type-api/20190426_http_request_message.jpg"><p>▲ HTTP 请求报文结构</p><img src="/2019-04/directly-use-docker-s-unix-socket-type-api/20190427_http_request_message_request_line.jpg"><p>▲ HTTP 请求报文 Request-Line</p><img src="/2019-04/directly-use-docker-s-unix-socket-type-api/20190427_http_message_body.jpg"><p>▲ HTTP 报文 Message Body</p><blockquote><p>注：一个CRLF由\r和\n构成，即CRLF=\r\n</p></blockquote><p><em>An entity consists of entity-header fields and an entity-body, although some responses will only include the entity-headers.</em></p><h4 id="message-body-和-entity-body"><a href="#message-body-和-entity-body" class="headerlink" title="message-body 和 entity-body"></a>message-body 和 entity-body</h4><p><em>The message-body (if any) of an HTTP message is used to carry the entity-body associated with the request or response. The message-body differs from the entity-body only when a transfer-coding has been applied.</em></p><p><em>The entity-body is obtained from the message-body by decoding any Transfer-Encoding that might have been applied to ensure safe and proper transfer of the message.</em></p><p>HTTP 报文的 message-body 用于携带与请求或响应关联的 entity-body。message-body 只有在应用“传输编码”时，才与 entity-body 不同。</p><h4 id="message-length-和-entity-length"><a href="#message-length-和-entity-length" class="headerlink" title="message-length 和 entity-length"></a>message-length 和 entity-length</h4><p><em>The transfer-length of a message is the length of the message-body as it appears in the message; that is, after any transfer-codings have been applied.</em></p><p><em>The entity-length of a message is the length of the message-body before any transfer-codings have been applied.</em></p><p>一个报文中的 transfer-length 长度是报文包含 message-body 时，message-body 应用传输编码之后的长度。<br>一个报文中的 entity-length 长度是 message-body 在应用传输编码之前的长度。</p><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>HTTP 主要有三类 Header Fields，<code>general-header</code>、<code>request-header</code>、<code>entity-header</code>，不同类别的 Header Fields 修饰的主体也不一样。这里简单说下需要用到的几个 Header Fields。</p><h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h4><p><em>A client MUST include a Host header field in all HTTP/1.1 request messages.</em><br>Host 是 request-header 的 field，在 HTTP/1.1 的请求报文中必须使用。</p><h4 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h4><p><em>Any HTTP/1.1 message containing an entity-body SHOULD include a Content-Type header field defining the media type of that body.</em><br>Content-Type 是 entity-header 的 field，HTTP/1.1的报文，如果包含 entity-body 则中必须使用。</p><h4 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h4><p><em>The Content-Length entity-header field indicates the size of the entity-body.</em></p><p><em>In HTTP, it SHOULD be sent whenever the message’s length can be determined prior to being transferred, unless this is prohibited by the rules in section 4.4.</em></p><p><em>For compatibility with HTTP/1.0 applications, HTTP/1.1 requests containing a message-body MUST include a valid Content-Length header field unless the server is known to be HTTP/1.1 compliant.</em></p><p>在 HTTP/1.1 报文最好包含 Content-Length，主要是兼用 HTTP/1.0。</p><h2 id="Docker-engine-API-参考-3"><a href="#Docker-engine-API-参考-3" class="headerlink" title="Docker engine API 参考 [3]"></a>Docker engine API 参考 [<a href="https://docs.docker.com/engine/api/v1.39/" target="_blank" rel="noopener">3</a>]</h2><p>参考 API 的简要使用说明。</p><img src="/2019-04/directly-use-docker-s-unix-socket-type-api/20190425_api_image_create.jpg"><p>▲ create image</p><p>其中的 <code>Query Parameters</code> 是指在附加在 URL 的参数，如 <code>abc.com?key_0=value&amp;key_1=value</code>。</p><img src="/2019-04/directly-use-docker-s-unix-socket-type-api/20190425_api_image_create_do_0.jpg"><p>▲ 通过 API 创建 image 演示</p><img src="/2019-04/directly-use-docker-s-unix-socket-type-api/20190425_api_image_create_do_1.jpg"><p>▲ 通过 API 创建 image 结果</p><img src="/2019-04/directly-use-docker-s-unix-socket-type-api/20190425_api_containers_create.jpg"><p>▲ create container</p><p><code>REQUEST BODY</code> 是放在 HTTP 报文中的 <code>Message-Body</code> 的数据，除此还需要在 HTTP 报文头指定 <code>Content-Type</code> 和 <code>Content-Length</code>。</p><img src="/2019-04/directly-use-docker-s-unix-socket-type-api/20190425_api_containers_create_do_0.jpg"><p>▲ 通过 API 创建 container 演示</p><img src="/2019-04/directly-use-docker-s-unix-socket-type-api/20190425_api_containers_create_do_1.jpg"><p>▲ 通过 API 创建 container 结果</p><img src="/2019-04/directly-use-docker-s-unix-socket-type-api/20190425_api_containers_Inspect_do_0.jpg"><p>▲ 通过 API 查看 container 信息</p><h2 id="使用-python-访问-unix-socket-API"><a href="#使用-python-访问-unix-socket-API" class="headerlink" title="使用 python 访问 unix-socket API"></a>使用 python 访问 unix-socket API</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">SK = <span class="string">"/var/run/docker.sock"</span></span><br><span class="line"><span class="comment"># docker engine socket 文件路径</span></span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 使用 socket.AF_UNIX 指定使用的是 unix-socket 类型的 socket，如果是 TCP 类的 socket，则是 socket.AF_INET 等。</span></span><br><span class="line"></span><br><span class="line">s.connect(SK)</span><br><span class="line"></span><br><span class="line">msg = (</span><br><span class="line"><span class="string">"GET /version HTTP/1.1\r\n"</span></span><br><span class="line"><span class="string">"Host: /\r\n"</span></span><br><span class="line"><span class="string">"\r\n"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 这里是关键，不要直接向 socket 发送一个“无格式”的请求，如 “GET /version”。</span></span><br><span class="line"></span><br><span class="line">s.sendall(msg.encode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">raw_data = []</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    tmp_data = s.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> tmp_data: <span class="keyword">break</span></span><br><span class="line">    raw_data.append(tmp_data)</span><br><span class="line"></span><br><span class="line">recv_b = <span class="string">b""</span>.join(raw_data)</span><br><span class="line">print(recv_b.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">s.close();</span><br></pre></td></tr></table></figure><p>如前面所说，docker engine 提供的是 HTTP 协议的 API，所以这里需要自己构造 HTTP 报文，而不能直接发送非 HTTP 报文结构的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msg = (</span><br><span class="line"><span class="string">"GET /version HTTP/1.1\r\n"</span></span><br><span class="line"><span class="string">"Host: /\r\n"</span></span><br><span class="line"><span class="string">"\r\n"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>Host</code> field 在 HTTP/1.1 中必须包含。实际，在这里，<code>Host</code> 只是为了符合 HTTP/1.1 报文的结构，<code>Host</code> 的值无关紧要，如<code>/a</code>、<code>/b</code>、<code>localhost</code>得到结果是一样的。</p><img src="/2019-04/directly-use-docker-s-unix-socket-type-api/20190427_py_0.jpg"><p>▲ 执行结果</p><p>API 响应的也是一个完整的 HTTP 报文。</p><p>只要更改请求的 HTTP 报文信息，就可以请求 API 的不同内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">body = <span class="string">'&#123;"Image":"nginx:alpine"&#125;'</span></span><br><span class="line">c_l = str(len(body))</span><br><span class="line"></span><br><span class="line">msg = (</span><br><span class="line"><span class="string">"POST /containers/create?name=mypy HTTP/1.1\r\n"</span></span><br><span class="line"><span class="string">"Host: /\r\n"</span></span><br><span class="line"><span class="string">"Content-Type: application/json\r\n"</span></span><br><span class="line"><span class="string">"Content-Length: &#123;c_l&#125;\r\n"</span></span><br><span class="line"><span class="string">"\r\n"</span></span><br><span class="line"><span class="string">"&#123;body&#125;"</span></span><br><span class="line">).format(c_l = c_l, body = body)</span><br></pre></td></tr></table></figure><p>如果包含 Message-Body，必须要指定 <code>Content-Type</code>，其类型为 <code>application/json</code> ，除此还需要计算 <code>engine-length</code>。</p><img src="/2019-04/directly-use-docker-s-unix-socket-type-api/20190427_py_1.jpg"><p>▲ 执行结果</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://docs.docker.com/engine/reference/commandline/dockerd/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/dockerd/</a><br>[2] <a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc2616</a><br>[3] <a href="https://docs.docker.com/engine/api/v1.39/" target="_blank" rel="noopener">https://docs.docker.com/engine/api/v1.39/</a></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> HTTP </tag>
            
            <tag> socket </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>use-the-tls-protect-docker-api</title>
      <link href="/2019-04/use-the-tls-protect-docker-api/"/>
      <url>/2019-04/use-the-tls-protect-docker-api/</url>
      
        <content type="html"><![CDATA[<p>使用TLS保护docker daemon的API。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果不使用TLS和不使用相关客户端证书对客户端身份进行验证，那么能够于服务器进行通信的任何主机（假设未进行其他防护措施），都可以访问该服务器上的docker daemon的TCP API（下称API）。</p><img src="/2019-04/use-the-tls-protect-docker-api/20190421_no_https.jpg"><p>▲ 未对客户端进行验证，API暴露</p><p>其实这是一个非常危险的行为，拥有API的访问权相当拥有了整个docker client（甚至更多）的功能。比如说通过API使用<code>mount bind</code>将服务器的某些重要目录（<code>/</code>，<code>/etc/</code>…）挂载到一个容器内部，通过容器就可以直接的对挂载进来的文件（夹）进行操作。</p><h2 id="使用-openssl-创建证书"><a href="#使用-openssl-创建证书" class="headerlink" title="使用 openssl 创建证书"></a>使用 openssl 创建证书</h2><p>首先是创建一个私有的CA根证书，然后使用此证书分别对服务端证书和客户端证书进行签名。</p><h3 id="证书请求文件资料"><a href="#证书请求文件资料" class="headerlink" title="证书请求文件资料"></a>证书请求文件资料</h3><table><thead><tr><th>缩写</th><th>含义</th></tr></thead><tbody><tr><td>C</td><td>Country Name</td></tr><tr><td>S</td><td>State or Province Name</td></tr><tr><td>L</td><td>Locality Name</td></tr><tr><td>O</td><td>Organization Name</td></tr><tr><td>OU</td><td>Organization Unit Name</td></tr><tr><td>CN</td><td>Common Name</td></tr><tr><td>emailAddress</td><td>Email Address</td></tr></tbody></table><p>CN设置哪个主机可以使用这个证书（客户端好像没这个限制）。<br>默认情况下，OpenSSL创建的证书只包含一个CN而且只能设置一个主机名。  </p><h4 id="例子（不同服务情况可以不一样）"><a href="#例子（不同服务情况可以不一样）" class="headerlink" title="例子（不同服务情况可以不一样）"></a>例子（不同服务情况可以不一样）</h4><p>如果服务器IP为1.1.1.1，并且申请一个证书，其CN为1.1.1.1。<br>那么将只能通过1.1.1.1访问服务器中使用此证书的服务。<br>如果在内部通过127.0.0.1、localhost，或者是主机的域名，访问服务器的中使用此证书的服务，会有如下指示：<br><em>unable to communicate securely with peer: requested domain name does not match the server’s certificate.</em></p><p>因为这个限制，即便你有其他相关联的站点，也不得不为每个站点生成一张单独的证书。解决方案是使用多域名的证书，实现方法有<code>X.509</code>的<code>SAN</code>（subjectalternative name）和泛域名（类似使用通配符）。<br>需要注意的是，如果使用<code>SAN</code>，CN将不生效。</p><h3 id="创建CA根证书"><a href="#创建CA根证书" class="headerlink" title="创建CA根证书"></a>创建CA根证书</h3><ol><li>生成CA私钥【ca-key.pem】</li><li>通过CA私钥【ca-key.pem】生成证书签名请求文件【ca.csr】</li><li>对证书签名请求文件【ca.csr】进行自签名生成CA根证书【ca.pem】</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成CA私钥【ca-key.pem】</span></span><br><span class="line">openssl genrsa -out ca-key.pem 2048</span><br><span class="line"><span class="comment"># 通过CA私钥【ca-key.pem】生成证书签名请求文件【ca.csr】</span></span><br><span class="line">penssl req -new -key ca-key.pem -out ca.csr</span><br><span class="line"><span class="comment"># 对证书签名请求文件【ca.csr】进行自签名生成CA根证书【ca.pem】</span></span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> ca.csr -out ca.pem -signkey ca-key.pem -days 365</span><br><span class="line"><span class="comment"># 可以将2、3结合成一步</span></span><br><span class="line">openssl req -new -x509 -days 365 -key ca-key.pem -out ca-cert.pem</span><br></pre></td></tr></table></figure><h3 id="创建服务端证书"><a href="#创建服务端证书" class="headerlink" title="创建服务端证书"></a>创建服务端证书</h3><ol><li>生成server私钥【server-key.pem】</li><li>通过server私钥【server-key.pem】生成证书签名请求文件【server.csr】</li><li>使用CA根证书【ca.pem】对服务端的证书签名请求文件【server.csr】进行签名生成服务端证书【server.pem】</li></ol><p>先创建一个X509V3扩展文件【extfile.cnf】，说明证书的用途，还有设置<code>SAN</code>，使一个证书可能支持多个主机。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extendedKeyUsage = serverAuth</span><br><span class="line">subjectAltName = IP:192.168.0.4,IP:127.0.0.1,IP:0.0.0.0,DNS:localhost</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成server私钥【server-key.pem】</span></span><br><span class="line">openssl genrsa -out server-key.pem 2048</span><br><span class="line"><span class="comment"># 通过server私钥【server-key.pem】生成证书签名请求文件【server.csr】</span></span><br><span class="line">penssl req -new -key server-key.pem -out server.csr</span><br><span class="line"><span class="comment"># 使用CA根证书【ca.pem】对服务端的证书签名请求文件【server.csr】进行签名生成服务端证书【server.pem】</span></span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> server.csr -out server-cert.pem -CA ca.pem -CAkey ca-key.pem -CAcreateserial -days 365 -extfile extfile.cnf</span><br></pre></td></tr></table></figure><h3 id="创建客户端证书"><a href="#创建客户端证书" class="headerlink" title="创建客户端证书"></a>创建客户端证书</h3><p>客户端证书和服务端证书的创建流程基本一样。</p><p>X509V3扩展文件【extfile.cnf】</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extendedKeyUsage = clientAuth</span><br></pre></td></tr></table></figure><p>在客户端中，客户端证书好像不受的CN及<code>SAN</code>的限制，这里就不设置了（有问题可以联系我）。</p><p>最后列下所需要的文件。</p><ul><li>CA根证书【ca.pem】</li><li>服务端证书【server.pem】</li><li>服务端私钥【server-key.pem】</li><li>客户端证书【clent.pem】</li><li>客户端端私钥【client-key.pem】</li></ul><p>如果需要在像windows上面浏览器上面使用客户端的证书和私钥，需要将客户端证书和客户端私钥打包成一个证书文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -<span class="built_in">export</span> -clcerts -<span class="keyword">in</span> client.pem -inkey client-key.pem -out client.p12</span><br></pre></td></tr></table></figure><p>对于CA根证书可以直接修改其后缀为<code>.cer</code>或者<code>.crt</code>。</p><h2 id="配置docker-daemon使用TSL"><a href="#配置docker-daemon使用TSL" class="headerlink" title="配置docker daemon使用TSL"></a>配置docker daemon使用TSL</h2><h3 id="Daemon配置"><a href="#Daemon配置" class="headerlink" title="Daemon配置"></a>Daemon配置</h3><ul><li><p><em>tlsverify, tlscacert, tlscert, tlskey</em> set: Authenticate clients<br><strong>双向验证</strong><br>要求验证客户端，其中包含的选项为ca、服务器证书、服务器私钥，且指定要求对客户端进行验证。</p></li><li><p><em>tls, tlscert, tlskey</em>: Do not authenticate clients<br><strong>单向验证</strong>（通常不使用这个模式）<br>不要求验证客户端，其中包含的选项为ca、服务器证书、服务器私钥。</p></li></ul><p>dockerd v18.09的配置配置文件路径为<code>/etc/docker/daemon.json</code>。因为是设置双向验证的模式，所以需要在配置的选项有<code>tlsverify</code>、<code>tlscacert</code>、<code>tlscert</code>、<code>tlskey</code>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"tlsverify"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">"tlscacert"</span>: <span class="string">"/root/docker-ca/ca.pem"</span>,</span><br><span class="line"><span class="attr">"tlscert"</span>: <span class="string">"/root/docker-ca/server/server-cert.pem"</span>,</span><br><span class="line"><span class="attr">"tlskey"</span>: <span class="string">"/root/docker-ca/server/server-key.pem"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，如果是使用<code>systemd</code>的系统，不能够在<code>daemon.json</code>中设置<code>hosts</code>，因为docker在<code>systemd</code>的启动脚本中已经使用了<code>-H</code>选项（与<code>hosts</code>作用一样）,重复使用的话，将导致dockerd启动失败。</p><p>原文：</p><blockquote><p>Note: You cannot set options in daemon.json that have already been set on daemon startup as a flag. On systems that use systemd to start the Docker daemon, -H is already set, so you cannot use the hosts key in daemon.json to add listening addresses. See <a href="https://docs.docker.com/engine/admin/systemd/#custom-docker-daemon-options" target="_blank" rel="noopener">https://docs.docker.com/engine/admin/systemd/#custom-docker-daemon-options</a> for how to accomplish this task with a systemd drop-in file.</p></blockquote><p>在使用<code>systemd</code>的系统中配置<code>-H</code>（<code>hosts</code>）的方法是配置docker的<code>systemd</code>启动脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemtcl edit docker.service</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/usr/bin/dockerd -H fd:// -H tcp://0.0.0.0:2376</span><br></pre></td></tr></table></figure><p>注意前面留空的<code>ExecStart</code>不能省略。</p><p>关于<code>2376</code>和<code>2375</code>端口，通常<code>2376</code>是在使用TSL时的API时使用的端口，而<code>2375</code>是没有使用TSL时的API端口，虽然不是硬性规定，不过还是应该遵循规范。</p><p>重启dockerd生效。</p><h2 id="测试docker-daemon-TSL-API"><a href="#测试docker-daemon-TSL-API" class="headerlink" title="测试docker daemon TSL API"></a>测试docker daemon TSL API</h2><img src="/2019-04/use-the-tls-protect-docker-api/20190421_no_client.jpg"><p>▲ 只安装CA根证书，不使用客户端证书</p><p>在没有客户端证书的情况下，服务端对客户端的身份验证不通过，访问API失败。</p><img src="/2019-04/use-the-tls-protect-docker-api/20190421_load_client.jpg"><p>▲ 安装客户端证书，访问服务端时要求验证客户端身份，选择证书</p><img src="/2019-04/use-the-tls-protect-docker-api/20190421_ok.jpg"><p>▲ 验证成功，成功访问API</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://docs.docker.com/engine/security/https/" target="_blank" rel="noopener">https://docs.docker.com/engine/security/https/</a></li><li><a href="https://unihon.github.io/2019-04/docker-api-https-installa-the-certificate-on-windows/">https://unihon.github.io/2019-04/docker-api-https-installa-the-certificate-on-windows/</a></li><li>&lt;&lt;HTTPS权威指南&gt;&gt; Ivan Ristić</li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TLS </tag>
            
            <tag> HTTPS </tag>
            
            <tag> API </tag>
            
            <tag> OpenSSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker-api-https-installa-the-certificate-on-windows</title>
      <link href="/2019-04/docker-api-https-installa-the-certificate-on-windows/"/>
      <url>/2019-04/docker-api-https-installa-the-certificate-on-windows/</url>
      
        <content type="html"><![CDATA[<p>在windows 10上面安装证书，访问docker使用了TLS的api。</p><p>现在我有一个通过docker-machine在本地创建的docker engine。因为其默认已经使用了双向验证的TLS，所以并不能通过http或者在没有相关证书的访问docker daemon的api。</p><a id="more"></a><img src="/2019-04/docker-api-https-installa-the-certificate-on-windows/20190420_curl.jpg"><p>▲ 没有相关证书，访问api失败</p><img src="/2019-04/docker-api-https-installa-the-certificate-on-windows/20190420_doc.jpg"><p>▲ curl使用证书相关文档</p><img src="/2019-04/docker-api-https-installa-the-certificate-on-windows/20190420_ca.jpg"><p>▲ curl使用证书访问api</p><p>因为是双向验证，服务端也需要验证客户端（curl）的身份，所以客户端需要提供客户端证书。<br>其中<code>--cert</code>是指客户端证书，<code>--key</code>是指客户端的私钥，而<code>--cacert</code>则是客户端用来验证服务端证书的<code>CA根证书</code>。<br>在使用相关证书后，curl成功的访问了docker daemon的api。因为没有指定相关的信息请求，所以这里返回了<code>{&quot;message&quot;:&quot;page not found&quot;}</code></p><p>接着，通过windows上的浏览器访问docker daemon的api，因为还没安装相关证书，所以失败了。</p><img src="/2019-04/docker-api-https-installa-the-certificate-on-windows/20190420_web_no_ca.jpg"><p>▲ 未安装证书时访问api</p><p>下面，在docker machine的默认目录<code>~/.docker/</code>，找到对应docker engine的证书文件。</p><img src="/2019-04/docker-api-https-installa-the-certificate-on-windows/20190420_files.jpg"><p>▲ docker engine相关文件</p><p>其中只有三个文件是我们需要的，如下：</p><ul><li>ca.pem：CA根证书</li><li>cert.pem：客户端证书</li><li>key.pem：客户端私钥</li></ul><p>其他的则是服务端的证书，及docker engine的一些信息文件，关于服务端证书为什么也在这，是因为docker-machine在创建docker engine时，一些初始化工作是在宿主机（这里是我的WSL）进行的，包括生成证书的工作。</p><p>然后对证书格式进行转换，以在windows上面安装。</p><p><code>ca.pem</code>CA根证书文件，直接修改后缀为<code>cer</code>或者是<code>crt</code>就可以让windows上的证书管理器识别了，这里的<code>.pem</code>后缀，指的是证书的编码为<code>PEM</code>，另外<code>DER</code>编码的证书直接修改后缀，也可以在windows上安装。</p><p>对于客户端证书和客户端私钥，需要将他们打包为一个证书文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ openssl pkcs12 -<span class="built_in">export</span> -clcerts -<span class="keyword">in</span> cert.pem -inkey key.pem -out docker_client.p12</span><br></pre></td></tr></table></figure><blockquote><p>关于PKCS#12：<br>描述个人信息交换语法标准。<br>描述了将用户公钥、私钥、证书和其他相关信息打包的语法。</p></blockquote><img src="/2019-04/docker-api-https-installa-the-certificate-on-windows/20190420_files_w.jpg"><p>▲ 转换后的证书文件</p><p>在windows直接双击证书文件就可以安装。需要注意的是，CA根证书文件，需要将其安装在“受信任的根证书颁发机构”，不然可能会将证书识别为“无效证书”。客户端证书则可以按默认值安装。</p><p><img id="sm" src="/2019-04/docker-api-https-installa-the-certificate-on-windows/20190420_load_ca.jpg">▲ 指定CA根证书的安装位置</p><img src="/2019-04/docker-api-https-installa-the-certificate-on-windows/20190420_web_ca.jpg"><p>▲ windows安装CA根证书后访问api</p><p>因为是是双向验证，这里只安装了CA根证书，还没安装客户端，所以服务端在验证客户端身份时没通过，访问失败。</p><p>在安装客户端证书后，继续访问api。</p><img src="/2019-04/docker-api-https-installa-the-certificate-on-windows/20190420_web_load.jpg"><p>▲ 提示选择证书</p><img src="/2019-04/docker-api-https-installa-the-certificate-on-windows/20190420_web_ok.jpg"><p>▲ 成功访问api</p><img src="/2019-04/docker-api-https-installa-the-certificate-on-windows/20190420_web_info.jpg"><p>▲ 通过api请求其他信息</p><p>在安装客户端证书后，在访问api时，如果服务端需要验证客户端身份，可以选择相关的客户端证书，如果验证成功，服务端则作出正常响应。</p><p>如果需要在windows上删除刚刚安装的证书，可以“运行 <code>certmgr.msc</code> ”，在证书管理器中管理相关证书。</p><img src="/2019-04/docker-api-https-installa-the-certificate-on-windows/20190420_rm.jpg"><p>▲ windows证书管理器</p><p>在“受信任的根证书颁发机构”里面，“颁发者”为“root”的证书，则是刚刚安装的CA根证书，可以查看相关信息进行再一步的确认；docker的客户端证书默认则是安装在“个人”的位置。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TLS </tag>
            
            <tag> HTTPS </tag>
            
            <tag> certificate </tag>
            
            <tag> CA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>the-problem-of-amh-iptables</title>
      <link href="/2019-04/the-problem-of-amh-iptables/"/>
      <url>/2019-04/the-problem-of-amh-iptables/</url>
      
        <content type="html"><![CDATA[<p>使用amh v4.2面板时的防火墙问题。</p><p>主机系统为Centos 6.10，防火墙为iptables v1.4.7。</p><p>最初目的为永久的关闭防火墙，所以使用<code>chkconfig iptables off</code>和<code>chkconfig ip6tables off</code>，将iptables的符号连接从各系统启动等级中移除。</p><img src="/2019-04/the-problem-of-amh-iptables/20190409_chkconfig_list.png"><p>▲ 禁用iptables的开机自启动</p><p>随后<code>reboot</code>重启主机，验证是否“永久”的将iptables禁用了。但是在开机后执行<code>services iptables stauts</code>发现iptables是正在运行的状态，再次查看利用<code>chkconfig</code>查看iptables的启动等级设置并没有“异常”，各个启动等级都为“off”。</p><img src="/2019-04/the-problem-of-amh-iptables/20190409_iptables_status.png"><p>▲ 重启后查看iptables状态，并没能“永久”禁用iptables</p><p>后面排查<code>~/.bashrc</code>、<code>~/.bash_profile</code>、<code>/etc/profile</code>、<code>/etc/profile.d/</code>，都没有找到与启动iptables相关的命令。</p><p>于是，就干脆把iptables的规则文件<code>/etc/sysconfig/iptables</code>给删除了吧，这样iptables就无法启动了。</p><img src="/2019-04/the-problem-of-amh-iptables/20190409_iptables_rm.png"><p>▲ 删除iptables规则文件，并测试</p><p>最后再<code>reboot</code>重启主机验证下…出乎意料的是，iptables还是自动启动了，而且防火墙的规则与之前似乎并没有变化。</p><img src="/2019-04/the-problem-of-amh-iptables/20190409_iptables_status.png"><p>▲ 重启后再次查看iptables状态，但还是自动启动了</p><p>于是乎，我在想规则文件<code>/etc/sysconfig/iptables</code>是不是没有引用，为此，我使用<code>iptables-save &gt; /etc/sysconfig/iptables</code>将当前的规则导出，并在此基础上添加一个规则。</p><img src="/2019-04/the-problem-of-amh-iptables/20190409_iptables_route.png"><p>▲ 新添加一条防火墙规则 </p><p>随后执行<code>services iptables restart</code>重启iptables，并执行<code>iptables -L -n</code>查看防火墙规则。</p><img src="/2019-04/the-problem-of-amh-iptables/20190409_iptables_l.png"><p>▲ 新添加的防火墙规则，生效</p><p>可见，规则文件<code>/etc/sysconfig/iptables</code>是有引用的，但是，为什么先前在删除iptables的规则文件后，自己手动<code>stop</code>、<code>start</code>明明是可以使得iptables因为找不到规则文件而启动失败的，而在<code>reboot</code>重启主机后iptables却能够照常启动。</p><p>再次<code>reboot</code>重启主机。</p><img src="/2019-04/the-problem-of-amh-iptables/20190409_iptables_status.png"><p>▲ 重启后查看iptables状态</p><p>在重启主机后查看iptables状态，iptables正在运行中，关键的是，刚刚在规则文件中新添加的规则并没有在使用到当前的规则中，规则文件<code>/etc/sysconfig/iptables</code>依然还有自己添加的规则，并没有“被改动”。</p><p>可以推断出，在系统启动时，iptables应该并不是从<code>/etc/sysconfig/iptables</code>中加载规则。</p><p>在排除了<code>~/.bashrc</code>之类文件后，我开始在<code>/etc/init.d/</code>下寻找怀疑对象。</p><img src="/2019-04/the-problem-of-amh-iptables/20190409_ls.png"><p>▲ <code>/etc/init.d/</code>目录里的内容</p><p>这个<strong>amh-start</strong>一看就很可疑啊…</p><img src="/2019-04/the-problem-of-amh-iptables/20190409_amh_start.png"><p>▲ <code>/etc/init.d/amh-start</code>文件内容</p><img src="/2019-04/the-problem-of-amh-iptables/20190409_chkconfig_list_amh.png"><p>▲ 查看amh-start的启动信息</p><p>这下什么都明白了。</p><p>回到上面的问题：</p><p>为什么永久禁用iptables不生效；为什么明明没有规则文件，在重启主机后iptables却依然能够自动启动。</p><p>因为每次系统启动都会执行amh-start脚本，里面的<code>iptables-restore</code>从<code>/etc/amh-iptables</code>中导入防火墙规则。</p><p>要永久禁用iptables，将这条<code>/sbin/iptables-restore &lt; /etc/amh-iptables</code>注释掉即可。</p><p>注：iptables-restore也会启动iptables</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iptables </tag>
            
            <tag> CentOS </tag>
            
            <tag> init </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker-pid-1-and-container-stop</title>
      <link href="/2019-04/docker-pid-1-and-container-stop/"/>
      <url>/2019-04/docker-pid-1-and-container-stop/</url>
      
        <content type="html"><![CDATA[<p>关于docker中容器的PID 1和容器停止过程的思考。</p><a id="more"></a><h2 id="PID-1"><a href="#PID-1" class="headerlink" title="PID 1"></a>PID 1</h2><p>容器的“入口进程”必须要保持前台运行，如果进程在后台运行（或进程结束），容器也会随之退出、停止。</p><p>可以这样理解，当启动一个容器时，便有一个“入口进程”即PID 1在容器中运行，“入口进程”在执行程序时可以产生其他子进程，不过，如果是通过&amp;或者其他途径在将子程序以后台的形式运行，那么“入口进程”将将继续顺序执行，如果中间没其他子程序堵塞，将一直执行到结束。当“入口进程”结束时，不管还有没有其他子进程在运行，都会退出容器，容器便停止了。</p><h2 id="docker-stop"><a href="#docker-stop" class="headerlink" title="docker stop"></a>docker stop</h2><p>在<code>dockerfile</code>的<code>ENTRYPOING</code>章节中有个比较有意思的地方。</p><blockquote><p>The shell form prevents any CMD or run command line arguments from being used, but has the disadvantage that your ENTRYPOINT will be started as a subcommand of /bin/sh -c, which does not pass signals. This means that the executable will not be the container’s PID 1 - and will not receive Unix signals - so your executable will not receive a SIGTERM from docker stop <container>.</container></p></blockquote><p>同时还有两个对比例子。</p><p>注：留意容器内PID 1进程是什么</p><img src="/2019-04/docker-pid-1-and-container-stop/20190405_use_exec.png"><p>▲ 使用exec，容器可以快速的停止</p><img src="/2019-04/docker-pid-1-and-container-stop/20190405_no_exec.png"><p>▲ 不使用exec，容器的停止的时间明显长很多</p><p>关于<code>docker stop</code>命令的解释是这样的：</p><blockquote><p>The main process inside the container will receive SIGTERM, and after a grace period, SIGKILL.</p></blockquote><p><code>docker stop</code>命令首先是给容器内部进程发送<code>SIGTERM</code>信号，超出宽限期（默认10s）即超时后便发送<code>SIGKILL</code>信号。</p><p>其实结合上面官方的解释中可以分析出，<code>docker stop</code>发送的信号实际上作用的对象是容器中的PID 1，即只有容器中的PID 1进程可以接收到<code>docker stop</code>发送的stop信号。</p><p>上面的没有使用<code>exec</code>的例子中，容器停止之所以花这么长时间，是因为容器没能正常停止（PID 1进程在收到stop信号后没结束），在超时（默认10s）后才被强制停止。</p><p>下面进入正题。</p><p>不管有没有使用<code>exec</code>，容器运行时都有PID 1进程（肯定、也必须有），既然stop信号的作用象是PID 1，那为什么，有的却会正常停止失败。</p><p>其实，虽然运行的容器中都有PID 1的程序进程，但不同的程序对信号的处理方式不一定相同。</p><img src="/2019-04/docker-pid-1-and-container-stop/20190405_pid_1_top.png"><p>▲ PID 1的top程序</p><img src="/2019-04/docker-pid-1-and-container-stop/20190405_pid_1_sh.png"><p>▲ PID 1的sh程序</p><p>这里我针对top和sh两个程序对<code>docker stop</code>的信号的处理方式进行测试，以一个alpine镜像分别运行两个容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面为主要命令，并不是同时执行</span></span><br><span class="line">$ docker run --rm --name top_p -it alpine top</span><br><span class="line">$ docker run --rm --name sh_p -it alpine sh</span><br></pre></td></tr></table></figure><h3 id="对top程序进行测试"><a href="#对top程序进行测试" class="headerlink" title="对top程序进行测试"></a>对top程序进行测试</h3><img src="/2019-04/docker-pid-1-and-container-stop/20190405_do_top.png"><p>▲ 启动top程序的单一进程容器：top_p</p><img src="/2019-04/docker-pid-1-and-container-stop/20190405_do_top_stop.png"><p>▲ 停止top程序的单一进程容器：top_p</p><p>容器的停止用时是0.209s，和默认的超时10s期限还差很远，得出的结果是容器可以正常停止。</p><h3 id="对sh程序进行测试"><a href="#对sh程序进行测试" class="headerlink" title="对sh程序进行测试"></a>对sh程序进行测试</h3><img src="/2019-04/docker-pid-1-and-container-stop/20190405_do_sh.png"><p>▲ 启动sh程序的单一进程容器：sh_p</p><p>注：忽略ps</p><img src="/2019-04/docker-pid-1-and-container-stop/20190405_do_sh_stop.png"><p>▲ 停止sh程序的单一进程容器：sh_p</p><p>容器的停止用时是10.252s，结果很明显，这个是超时的，容器不可以正常停止。</p><p>到这里，我对sh程序进行更深入的测试，以证明，是因为PID 1的sh程序的进程在接收到<code>docker stop</code>的信号后没做“结束进程”的处理而导致容器不可以正常停止。</p><p><code>trap</code>可以监视并拦截的Linux信号，这里我使用<code>trap</code>来拦截<code>docker stop</code>的信号，并在拦截到信号后结束进程（PID 1进程）。</p><img src="/2019-04/docker-pid-1-and-container-stop/20190405_trap_sh.png"><p>▲ 启动sh程序的单一进程容器，并使用<code>trap</code>拦截信号：sh_p</p><img src="/2019-04/docker-pid-1-and-container-stop/20190405_trap_sh_stop.png"><p>▲ 停止sh程序的单一进程容器：sh_p</p><p>注：实际上在trap拦截到信号后，要按一下回车才执行信号处理，没找到原因，不过不影响测试目的</p><p>容器的停止用时是1.227s！没有超时（10s），容器正常的停止了。</p><h3 id="测试结论"><a href="#测试结论" class="headerlink" title="测试结论"></a>测试结论</h3><p>通过对top和sh两个程序对<code>docker stop</code>的信号的处理方式的测试结果可以得出的结论是，容器是否能正常停止，和容器中PID 1的程序进程对<code>docker stop</code>的信号处理方式有关。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>容器是否正在运行的判定标准是容器内的PID 1是否存活。</p><p>能不能优雅停止容器的关键是PID 1在收到stop信号后，PID1自己作不作出结束进程的反应，与PID 1进程有没有子进程无关，如果，PID 1在收到stop信息后能结束自身进程，则可以优雅停止。</p><blockquote><p>注：实验用例太少，并不能证明结论是100%正确的，如有疑问，可以联系本人。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PID-1 </tag>
            
            <tag> process </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>set-vim-to-automatically-recognize-dockerfile</title>
      <link href="/2019-04/set-vim-to-automatically-recognize-dockerfile/"/>
      <url>/2019-04/set-vim-to-automatically-recognize-dockerfile/</url>
      
        <content type="html"><![CDATA[<p>vim对不同的文件类型有不同的语法高亮、格式、引用插件等功能。之前一直用vim写dockerfile都没发现dockerfile也有语法高亮，原因是vim没自动识别<code>dockerfile</code>类型文件。</p><a id="more"></a><img src="/2019-04/set-vim-to-automatically-recognize-dockerfile/20190402_vim_no_set_ft.png"><p>▲ vim不识别dockerfile文件类型</p><p>可以通过<code>:set filetype=dockerfile</code>在vim中指定文件的类型。</p><img src="/2019-04/set-vim-to-automatically-recognize-dockerfile/20190402_vim_set_ft.png"><p>▲ 通过<code>:set filetype=dockerfile</code>指定dockerfile文件类型</p><p>也可以在dockerfile文件头中加个注释<code># vim: set filetype=dockerfile</code>，让vim识别，不过这个方法似乎有点问题，vim实际上并没有按我们预期的那样工作，文件类型识别为其他的类型了，原因不明，猜测是配置文件没正解链接加载到dockerfile文件类型。</p><img src="/2019-04/set-vim-to-automatically-recognize-dockerfile/20190402_vim_set_ft_on_head.png"><p>▲ 在文件头指定dockerfile文件类型</p><p>上面的两种方法都不是我想要的。第一，我肯定不会为一个语法高亮每次都手动的指定文件类型，第二，我不想在dockerfile添加和主题无关的内容。</p><p>下面这种“真自动识别”文件类型的方法才是我想要的。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">C. If your <span class="keyword">file</span> <span class="built_in">type</span> can <span class="keyword">be</span> detected by the <span class="keyword">file</span> name.</span><br><span class="line">   <span class="number">1</span>. Create your user <span class="keyword">runtime</span> directory.  You would normally use the <span class="keyword">first</span></span><br><span class="line">      item of the <span class="string">'runtimepath'</span> option.  Example <span class="keyword">for</span> Unix: </span><br><span class="line">        :!mkdir ~/.<span class="keyword">vim</span></span><br><span class="line"></span><br><span class="line">   <span class="number">2</span>. Create <span class="keyword">a</span> <span class="keyword">file</span> that contains autocommands <span class="keyword">to</span> detect the <span class="keyword">file</span> <span class="built_in">type</span>.</span><br><span class="line">      Example: </span><br><span class="line">        <span class="comment">" my filetype file</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">exists</span>(<span class="string">"did_load_filetypes"</span>)</span><br><span class="line">          <span class="keyword">finish</span></span><br><span class="line">        <span class="keyword">endif</span></span><br><span class="line">        <span class="keyword">augroup</span> filetypedetect</span><br><span class="line">          au! BufRead,BufNewFile *.mine         <span class="keyword">setfiletype</span> mine</span><br><span class="line">          au! BufRead,BufNewFile *.xyz          <span class="keyword">setfiletype</span> drawing</span><br><span class="line">        <span class="keyword">augroup</span> END</span><br><span class="line">     Write this <span class="keyword">file</span> <span class="keyword">as</span> <span class="string">"filetype.vim"</span> in your user <span class="keyword">runtime</span> directory.  For</span><br><span class="line">      example, <span class="keyword">for</span> Unix: </span><br><span class="line">        :<span class="keyword">w</span> ~/.<span class="keyword">vim</span>/<span class="keyword">filetype</span>.<span class="keyword">vim</span></span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>. To use the <span class="keyword">new</span> <span class="keyword">filetype</span> detection you must restart Vim.</span><br><span class="line"></span><br><span class="line">   Your <span class="keyword">filetype</span>.<span class="keyword">vim</span> will <span class="keyword">be</span> sourced before the default FileType autocommands</span><br><span class="line">   have been installed.  Your autocommands will <span class="keyword">match</span> <span class="keyword">first</span>, <span class="built_in">and</span> the</span><br><span class="line">   <span class="string">":setfiletype"</span> <span class="keyword">command</span> will <span class="keyword">make</span> sure that <span class="keyword">no</span> other autocommands will <span class="keyword">set</span></span><br><span class="line">   <span class="string">'filetype'</span> after this.</span><br></pre></td></tr></table></figure><p>方法是新建一个<code>~/.vim/filetype.vim</code>，内容如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">exists</span>(<span class="string">"did_load_filetypes"</span>)</span><br><span class="line"><span class="keyword">finish</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">augroup</span> filetypedetect</span><br><span class="line">au! BufRead,BufNewFile dockerfile   <span class="keyword">setfiletype</span> dockerfile</span><br><span class="line"><span class="keyword">augroup</span> END</span><br></pre></td></tr></table></figure><p>这样，vim就可以自动的识别dockerfile文件的类型了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://vimhelp.org/filetype.txt.html" target="_blank" rel="noopener">https://vimhelp.org/filetype.txt.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dockerfile </tag>
            
            <tag> Config </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh-does-not-use-pubkey-for-login-verification</title>
      <link href="/2019-03/ssh-does-not-use-pubkey-for-login-verification/"/>
      <url>/2019-03/ssh-does-not-use-pubkey-for-login-verification/</url>
      
        <content type="html"><![CDATA[<p>虽然ssh利用密钥对进行登录验证很方便，也比手动输入的密码验证要安全，不过有时会需要针对某个主机不使用密钥对进行验证。</p><a id="more"></a><p><strong>EnableSSHKeysign</strong></p><p>Setting this option to yes in the global client configuration file /etc/ssh/ssh_config enables the use of the helper program ssh-keysign(8) during HostbasedAuthentication. The argument must be yes or no (the default). This option should be placed in the non-hostspecific section. See ssh-keysign(8) for more information.</p><p>当设置<code>EnableSSHKeysign</code>值为<code>no</code>时便禁用了密钥对的验证方式。可以在相关的配置文件进行“全局、永久性”的设置，也可以通过ssh命令的<code>-o</code>参数临时性的设置。</p><img src="/2019-03/ssh-does-not-use-pubkey-for-login-verification/20190331_ssh_login.gif"><p>▲ 在ssh命令行中针对某主机临时性设置不使用密钥对验证</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://man.openbsd.org/ssh_config" target="_blank" rel="noopener">https://man.openbsd.org/ssh_config</a></li><li><a href="https://man.openbsd.org/ssh" target="_blank" rel="noopener">https://man.openbsd.org/ssh</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
            <tag> command </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>build-the-lnmp-with-docker</title>
      <link href="/2019-03/build-the-lnmp-with-docker/"/>
      <url>/2019-03/build-the-lnmp-with-docker/</url>
      
        <content type="html"><![CDATA[<p>docker推崇单镜像单个服务，所以使用<a href="https://hub.docker.com/_/nginx" target="_blank" rel="noopener">nginx</a>、<a href="https://hub.docker.com/_/php" target="_blank" rel="noopener">php</a>、<a href="https://hub.docker.com/_/mariadb" target="_blank" rel="noopener">mariadb</a>三个镜像搭建lnmp，为了减小体积，除了mariadb，其他镜像统一使用alpine的版本。</p><a id="more"></a><p>因为是开发测试所用的lnmp环境，所以这是搭建lnmp只是单纯的“多容器应用”，与多<code>service</code>应用<code>stack</code>不同的是，容器应用不需要使用<code>swarm mode</code>。</p><img src="/2019-03/build-the-lnmp-with-docker/20190326_tree.png"><p>▲ 目录结构</p><h2 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.5"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">    nginx:</span></span><br><span class="line"><span class="attr">        build:</span> <span class="string">./nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:alpine-lnmp</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">"80:80"</span></span><br><span class="line"><span class="attr">        volumes:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">/home/docker/lnmp:/var/www/html</span></span><br><span class="line"><span class="attr">        networks:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">lnmp</span></span><br><span class="line"><span class="attr">    php-fpm:</span></span><br><span class="line"><span class="attr">        build:</span> <span class="string">./php-fpm</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">php:fpm-alpine-lnmp</span></span><br><span class="line"><span class="attr">        volumes:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">/home/docker/lnmp:/var/www/html</span></span><br><span class="line"><span class="attr">        networks:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">lnmp</span></span><br><span class="line"><span class="attr">    mariadb:</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">mariadb:latest</span></span><br><span class="line"><span class="attr">        environment:</span></span><br><span class="line"><span class="attr">            MYSQL_ROOT_PASSWORD:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">            MYSQL_USER:</span> <span class="string">username</span></span><br><span class="line"><span class="attr">            MYSQL_PASSWORD:</span> <span class="string">abc</span></span><br><span class="line"><span class="attr">        volumes:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">/home/docker/db_data:/var/lib/mysql</span></span><br><span class="line"><span class="attr">        networks:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">lnmp</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">    lnmp:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">lnmp</span></span><br></pre></td></tr></table></figure><p>为了网站页面资源能够在nginx和php容器间共享，且为了方便调试，这里使用的<code>bind mount</code>的方式将主机目录同时挂载到nginx和php对应的网站根目录。为了数据库的数据持久化，也对其使用volume或者挂载本地目录，可以通过镜像说明的配置方法预先对数据库进行一些配置，更多信息可以参阅<a href="https://hub.docker.com/_/mariadb" target="_blank" rel="noopener">mariadb docker-hub的说明</a>。</p><h2 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h2><h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><p>dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx:alpine</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">"mkdir"</span>,<span class="string">"-p"</span>,<span class="string">"/var/www/html"</span>]</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./default.conf /etc/nginx/conf.d</span></span><br></pre></td></tr></table></figure><p>nginx的配置文件。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line"><span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line"><span class="attribute">root</span>   /var/www/html;</span><br><span class="line"><span class="attribute">index</span>  index.html index.php;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line"><span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line"><span class="attribute">root</span>   /var/www/html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line"><span class="attribute">root</span>   /var/www/html;</span><br><span class="line"><span class="attribute">fastcgi_pass</span>   php-fpm:<span class="number">9000</span>;</span><br><span class="line"><span class="attribute">fastcgi_index</span>  index.php;</span><br><span class="line"><span class="attribute">fastcgi_param</span>  SCRIPT_FILENAME  <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line"><span class="attribute">include</span>        fastcgi_params;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="php-fpm"><a href="#php-fpm" class="headerlink" title="php-fpm"></a>php-fpm</h3><p>dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> php:fpm-alpine</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sed -i <span class="string">'s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g'</span> /etc/apk/repositories &amp;&amp; \</span></span><br><span class="line"><span class="bash">docker-php-ext-install mysqli &amp;&amp; \</span></span><br><span class="line"><span class="bash">docker-php-ext-install pdo_mysql</span></span><br></pre></td></tr></table></figure><p>php镜像给php安装扩展，这里用的是镜像提供的便捷脚本<code>docker-php-ext-install</code>，这个脚本是通过编译扩展源码的方式安装扩展，因此，在此之前会自动下载、安装一系列的开发工具，如gcc等，在完成对扩展源码的编译、安装工作后会自动清除此前的编译环境，所以不用担心最后的生成的镜像会存在一些不需要的开发工具。官方php镜像提供了好几种安装扩展的方法，更多信息可以参阅<a href="https://hub.docker.com/_/php" target="_blank" rel="noopener">php docker-hub的说明</a>。当然，也可以自己直接通过包管理工具下载安装扩展，不过需要注意，扩展的版本与php的版本不一致，可能会不兼容。</p><img src="/2019-03/build-the-lnmp-with-docker/20190326_up.png"><p>▲ 启动lnmp，查看多容器应用lnmp状态</p><img src="/2019-03/build-the-lnmp-with-docker/20190326_show.png"><p>▲ 运行效果</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LNMP </tag>
            
            <tag> Linux </tag>
            
            <tag> Nginx </tag>
            
            <tag> Mariadb </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>boot2docker-docker-machine-ssh</title>
      <link href="/2019-02/boot2docker-docker-machine-ssh/"/>
      <url>/2019-02/boot2docker-docker-machine-ssh/</url>
      
        <content type="html"><![CDATA[<p>因为docker是基于linux上的一些特性而实现的。目前为止，如果想在非linux环境下安装docker engnie，即运行docker守护进程的主机，就得先提供一个linux环境为docker技术的实现提供低层支持。为此docker官方准备了一个为docker定制“linux发行版本”——boot2docker（下称b2d)。不管现在的docker desktop还是以前的docker toolbox，从原理上来说并没有变化，其核心都是围绕着如何让boot2docker（linux环境）更好、更便捷的在非linux主机上跑起来。</p><a id="more"></a><p>官方推荐的是将boot2docker与docker-machine还有一款虚拟化工具一起搭配使用。windows10与windows10以前的区别是，官方将其中的虚拟化工具由virtualbox，换成了windows10 Pro自带的hyper-v。</p><p>在b2d中发现的一些有趣的东西。利用docker-machine创建一个docker engine（指基于b2d的docker engine，下文同），可以发现整个过程是“全自动”的。可以知道的是docker-machine默认是通过ssh通道连接docker engine，既然是ssh，那为什么在docker engine创建完成之后就可以直接通过docker-machine提供的命令<code>docker-machine ssh name</code>或者是通过<code>ssh docker@ip</code>都可以直接的登录（无需输入任何信息）到新建的docker engine。当然ssh可以通过公、密钥的认证方式就可以实现“免密码”的登录。其实，docker engine和docker-machine确实是通过公、密钥认证的。可以通过ssh等方式查看docker engine家目录下查看.ssh目录，里面的authorized_keys文件中的和一行公钥是和主机的公钥是一样的。</p><p>现在的疑问就是：</p><ol><li>boot2docker、docker-machine是主机的公钥“发送”到docker engine的；</li><li>boot2docker是一个只读镜像，他又是将公钥保存在哪的。</li></ol><p>ssh目前并没有相关的命令参数可以指定用户及登录密码，ssh、scp如果要连接远程主机会进入一个“交互模式”，用户需要手动输入密码等信息。</p><img src="/2019-02/boot2docker-docker-machine-ssh/20190227_ssh_tty.png"><p>▲ ssh连接远程主机时需要手动输入信息</p><p>这样的话，如果要在脚本中实现ssh“自动登录”则需要借助一些其他的软件如expect（单单通过|管道不能给ssh填充密码）。可知的是在安装docker-machine之后，主机并没有安装expect之类的软件，当然也可能通过其他手段实现ssh的自动登录。</p><p>至于docker engine的公钥保存方式，不难知道，公钥应该是保存在docker engine的<code>/var/lib/boot2docker</code>，也就是<code>/mnt/sda1/var/lib/boot2docker</code>，实际上用户的数据都保存在这里，docker的镜像、容器之类的数据则保存在<code>/var/lib/docker</code>，即<code>/mnt/sda1/var/lib/docker</code>。</p><img src="/2019-02/boot2docker-docker-machine-ssh/20190227_b2d_dir.png"><p>▲ b2d目录关系</p><p>在<code>/mnt/sda1/var/lib/boot2docker</code>下有个，<code>ssh</code>目录，实际上公钥并不在这个目录，公钥保存在<code>/mnt/sda1/var/lib/boot2docker</code>目录下的一个名为<code>userdata.tar</code>的tar包中。</p><img src="/2019-02/boot2docker-docker-machine-ssh/20190227_b2d_data.png"><p>▲ b2d用户数据</p><p>通过测试，boot2docker确实是在系统启动时，将<code>userdata.tar</code>的内容解包到家目录。</p><p>现在又回到第一个问题，docker-machine、b2d，是怎样将主机的公钥打包到docker engine的<code>/mnt/sda1/var/lib/boot2docker/userdata.tar</code>。因为b2d可以自动挂载主机的共享目录，在想会不是是通过这样的方式将提前准备好的<code>userdata.tar</code>“共享到指定目录”，不过后面尝试基本需要ssh连接docker engine进行几次的命令操作，如果这样和之前就没什么区别了。</p><p>在阅读docker-machine和b2d的源码之前，我一直在思考他是怎么通过脚本进行ssh的自动登录，其实不然。</p><img src="/2019-02/boot2docker-docker-machine-ssh/20190227_b2d_source_userdata.png"><p>▲ <a href="https://github.com/boot2docker/boot2docker/blob/master/files/init.d/autoformat#L23-L50" target="_blank" rel="noopener">b2d在初始化时生成userdata.tar</a></p><img src="/2019-02/boot2docker-docker-machine-ssh/20190227_b2d_source_userdata_ssh.png"><p>▲ <a href="https://github.com/boot2docker/boot2docker/blob/master/files/init.d/autoformat#L151-L158" target="_blank" rel="noopener">b2d在启动时将userdata.tar解包到家目录</a></p><p>从源码中可以感觉<code>userdata.tar</code>是从某个设备、目录的数据导出的。不过我还是没知道他是从哪得到userdata.tar的原始数据。为此我发了个issue，请参阅<a href="https://github.com/boot2docker/boot2docker/issues/1379" target="_blank" rel="noopener">关于userdata.tar数据来源的提问</a>。</p><p>管理员的回答让我有点惊喜，因为我刚好在研究这一部分，关于docker-machine在生成docker engine时，处理虚拟硬盘的代码。</p><img src="/2019-02/boot2docker-docker-machine-ssh/20190227_dm_source_userdata.png"><p>▲ <a href="https://github.com/docker/machine/blob/61ef47dc5d6b1658e3d6636f9382d50507c8c7e1/libmachine/mcnutils/b2d.go#L485-L542" target="_blank" rel="noopener">docker machine在将主机的公钥打开成tar，生成数据流</a></p><img src="/2019-02/boot2docker-docker-machine-ssh/20190227_dm_source_vm.png"><p>▲ <a href="https://github.com/docker/machine/blob/61ef47dc5d6b1658e3d6636f9382d50507c8c7e1/libmachine/mcnutils/b2d.go#L485-L542" target="_blank" rel="noopener">docker machine通过VboxManage生成虚拟硬盘及相关处理</a></p><p>这部分代码前后有点多，在大概有2、3个关联文件，其中的主要思想如下：</p><ol><li>将主机的公钥打包，生成数据流；</li><li>打开相关的“管道”，通过VboxManage的<code>convertfromraw stdin</code>命令创建虚拟硬盘；</li><li>通过“管道”将先前打包的公钥数据流写入虚拟硬盘；</li><li>处理虚拟硬盘头信息，写入魔法标记“boot2docker, please format-me”等。</li></ol><p>这样，docker-machine就将主机的公钥写入了虚拟硬盘。前面的关于“boot2docker在哪得到userdata的源数据”疑问也解释了。</p><p>最后描述下docker engine初始化时处理“公钥”的过程：</p><ol><li>第一次启动时，脚本会扫描系统挂载的硬盘，并逐一的扫描硬盘头的信息，以寻找魔法标记“boot2docker, please format-me”；</li><li>如果没能找到魔法标记则，跳过生成<code>userdata.tar</code>，如果找到了魔法标记，便从硬盘特定位置通过<code>dd</code>将里面的userdata数据导出到本地的<code>userdata.tar</code>；</li><li>如果<code>userdata.tar</code>存在，则将其解压到家目录。</li></ol><p>这样，就解释了在创建好docker enginer后，为什么可以直接的ssh进入docker enginer。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VirtualBox </tag>
            
            <tag> ssh </tag>
            
            <tag> boot2docker </tag>
            
            <tag> docker-machine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>use an overlay network for standalone containers</title>
      <link href="/2019-02/use-an-overlay-network-for-standalone-containers/"/>
      <url>/2019-02/use-an-overlay-network-for-standalone-containers/</url>
      
        <content type="html"><![CDATA[<p>因为overlay网络必须要初始化一个swarm，所以需要开放以下端口：</p><ul><li>用于集群管理通信的TCP 2377端口</li><li>用于节点之间通信的TCP、UDP 7946端口</li><li>用于overlay网络流量传输的UDP 4789端口</li></ul><p>使用overlay网络让在不同的Docker主机上运行的容器能够通信。</p><a id="more"></a><p>选择一个manager主机，并使用<code>docker swarm init</code>命令初始化一个swarm，如果主机上有多个网络接口，需要在刚刚的命令上加上<code>--advertise-addr=&lt;IP-ADDRESS-OF-MANAGER&gt;</code>参数来指定使用的接口地址（在初始化swarm后会返回一个TOKEN，需要记录下来）。其他主机则使用如下命令连接刚刚初始化的swarm。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm join --token &lt;TOKEN&gt; \</span><br><span class="line">  --advertise-addr &lt;IP-ADDRESS-OF-WORKER-1&gt; \</span><br><span class="line">  &lt;IP-ADDRESS-OF-MANAGER&gt;:2377</span><br></pre></td></tr></table></figure><p>查看swarm节点的相关信息。</p><img src="/2019-02/use-an-overlay-network-for-standalone-containers/20190215_swarm_node.png"><p>▲ 查看各个节点状态</p><img src="/2019-02/use-an-overlay-network-for-standalone-containers/20190215_swarm_node_network.png"><p>▲ 查看各个节点的docker网络</p><p>后面的操作只需要两个docker主机演示，manager主机——Hon_Docker和另一个节点主机——Hon_Docker_0。</p><p>首先在manager主机上创建一个自定义的overlay网络<code>test-net</code>，并启动一个容器<code>alpine1</code>。（注意只需要在manager主机上创建<code>test-net</code>，其他节点主机如果需要<code>test-net</code>则会自动创建）。</p><img src="/2019-02/use-an-overlay-network-for-standalone-containers/20190215_swarm_node_network_0.png"><p>▲ 在manager上创建网络及其他操作</p><p>从图中，可以看到，在manager主机创建<code>test-net</code>后，Hon_Docker_0并没有在本地“同步创建”<code>test-net</code>。然后在Hon_Docker_0启动一个容器<code>alpine2</code>并指定使用<code>test-net</code>网络。再次查看Hon_Docker_0的docker网络信息，这时<code>test-net</code>已经自动创建。</p><p>接着切换到manager主机上的<code>alpine1</code>，并ping Hon_Docker_0主机上<code>alpine2</code>，同样的从<code>alpine2</code> ping <code>alpine1</code>，从测试结果中可以看到是互通的（这种直接通过容器名解析到容器IP的能力，之前在<strong>使用用户自定义桥接网络</strong>的章节中有看到解释：<em>resolve a container name to an IP address. This capability is called automatic service discovery.</em>，两个原理应该一样）。</p><img src="/2019-02/use-an-overlay-network-for-standalone-containers/20190215_node_communicate.png"><p>▲ 运行在不同主机上的容器通信测试</p><p>相对于manager主机，节点主机如果不再有容器使用<code>test-net</code>，节点主机便会在本地自动删除<code>test-net</code>（manager主机上的<code>test-net</code>需要手动删除）。</p><img src="/2019-02/use-an-overlay-network-for-standalone-containers/20190215_swarm_node_end.png"><p>▲ <code>alpine2</code>退出后，Hon_Docker_0主机自动删除<code>test-net</code></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://docs.docker.com/network/network-tutorial-overlay/" target="_blank" rel="noopener">https://docs.docker.com/network/network-tutorial-overlay/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
            <tag> communicate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>the problem of using special characters in the title of the article</title>
      <link href="/2019-02/the-problem-of-using-special-characters-in-the-title-of-article/"/>
      <url>/2019-02/the-problem-of-using-special-characters-in-the-title-of-article/</url>
      
        <content type="html"><![CDATA[<p>在给文章的title加入一个方括号<code>[]</code>后，在生成静态文件时报错了，并且给title新加入的方括号也没有生效。</p><a id="more"></a><img src="/2019-02/the-problem-of-using-special-characters-in-the-title-of-article/20190211_title_error.png"><p>▲ 给title加入<code>[]</code>后报错</p><p>想下应该需要转义一下，后面给<code>[]</code>加上<code>\</code>。</p><img src="/2019-02/the-problem-of-using-special-characters-in-the-title-of-article/20190211_title_no.png"><p>▲ 加上转义字符后，报错消除</p><p>加上转义字符后，报错消除了，不过在生成的title中转义字符也跟着出来了。后面接着试了下<code>*</code>之类的字符，情况和<code>[]</code>一样。</p><p>为此还特地去现在博客用的Markdown解释器<code>marked</code>的github上面看了一下配置，请参阅<a href="https://github.com/hexojs/hexo-renderer-marked" target="_blank" rel="noopener">hexo-renderer-marked</a>。改了几个配置发现都没什么变化。后面直接给title试了几个MD的标签，证实title不经MD解释器处理~~白折腾一番。</p><p>最后是通过加title加个双引号<code>&quot;&quot;</code>给解决了。</p><img src="/2019-02/the-problem-of-using-special-characters-in-the-title-of-article/20190211_title_ok.png"><p>▲ 给title加上<code>&quot;&quot;</code>后，正常显示特殊字符</p><p>解决问题，需要“有根据”的进行推敲（<del>其实是瞎折腾</del>）…</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> characters </tag>
            
            <tag> title </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[docker] disable networking for a container</title>
      <link href="/2019-02/docker-disable-networking-for-a-container/"/>
      <url>/2019-02/docker-disable-networking-for-a-container/</url>
      
        <content type="html"><![CDATA[<blockquote><p>【翻译】相关声名：<a href="https://unihon.github.io/2019-01/statement-of-some-blog-articles/">https://unihon.github.io/2019-01/statement-of-some-blog-articles/</a></p></blockquote><a id="more"></a><blockquote><p>Docker v18.09<br>Configure networking<br>Disable networking for a container<br>原文链接：<a href="https://docs.docker.com/network/none/" target="_blank" rel="noopener">https://docs.docker.com/network/none/</a></p></blockquote><h1 id="禁用容器的网络连接"><a href="#禁用容器的网络连接" class="headerlink" title="禁用容器的网络连接"></a>禁用容器的网络连接</h1><p>如果你想要完全禁用容器上的网络堆栈，可以在启动容器时使用<code>--network none</code>参数。在容器内仅创建环回设备。以下示例说明了这一点。</p><ol><li>创建容器。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -dit \</span><br><span class="line">  --network none \</span><br><span class="line">  --name no-net-alpine \</span><br><span class="line">  alpine:latest \</span><br><span class="line">  ash</span><br></pre></td></tr></table></figure><ol start="2"><li>通过在容器中执行一些常见的网络命令来检查容器的网络堆栈。请注意，没有创建<code>eth0</code>。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> no-net-alpine ip link show</span><br><span class="line"></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: tunl0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN qlen 1</span><br><span class="line">    link/ipip 0.0.0.0 brd 0.0.0.0</span><br><span class="line">3: ip6tnl0@NONE: &lt;NOARP&gt; mtu 1452 qdisc noop state DOWN qlen 1</span><br><span class="line">    link/tunnel6 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00 brd 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> no-net-alpine ip route</span><br></pre></td></tr></table></figure><p>第二条命令返回空，因为没有路由表。</p><ol start="3"><li>停止容器。它会被自动删除，因为它在创建时使用了<code>--rm</code>参数。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container rm no-net-alpine</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
            <tag> translation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[docker] use host networking</title>
      <link href="/2019-02/docker-use-host-networking/"/>
      <url>/2019-02/docker-use-host-networking/</url>
      
        <content type="html"><![CDATA[<blockquote><p>【翻译】相关声名：<a href="https://unihon.github.io/2019-01/statement-of-some-blog-articles/">https://unihon.github.io/2019-01/statement-of-some-blog-articles/</a></p></blockquote><a id="more"></a><blockquote><p>Docker v18.09<br>Configure networking<br>Use host networking<br>原文链接：<a href="https://docs.docker.com/network/host/" target="_blank" rel="noopener">https://docs.docker.com/network/host/</a></p></blockquote><h1 id="使用host网络"><a href="#使用host网络" class="headerlink" title="使用host网络"></a>使用host网络</h1><p>如果你对容器使用host网络驱动程序，则该容器的网络堆栈不会与Docker主机隔离。例如，如果你运行绑定到83端口的容器并使用host网络，则容器的应用程序将在主机IP地址的80端口上可用。</p><p>host网络驱动程序只能工作在Linux主机上，Docker Desktop for Mac和Docker Desktop for Windows或者Docker EE for Windows Server并不支持。</p><p>在Docker 17.06及更高版本中，你也可以将<code>--network host</code>加到<code>docker container create</code>命令，为swarm service使用<code>host</code>网络。在这种情况下，控制流量（与管理swarm和service相关的流量）仍然通过overlay网络发送，但是各个swarm服务容器使用Docker守护程序的主机网络和端口发送数据。这会产生一些额外的限制。例如，如果服务容器绑定到80端口，则只有一个服务容器可以在给定的swarm节点上运行。</p><p>如果你的容器或服务未发布端口，则主机网络无效。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
            <tag> translation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[docker] use overlay networks</title>
      <link href="/2019-02/docker-use-overlay-networks/"/>
      <url>/2019-02/docker-use-overlay-networks/</url>
      
        <content type="html"><![CDATA[<blockquote><p>【翻译】相关声名：<a href="https://unihon.github.io/2019-01/statement-of-some-blog-articles/">https://unihon.github.io/2019-01/statement-of-some-blog-articles/</a></p></blockquote><a id="more"></a><blockquote><p>Docker v18.09<br>Configure networking<br>Use overlay networks<br>原文链接：<a href="https://docs.docker.com/network/overlay/" target="_blank" rel="noopener">https://docs.docker.com/network/overlay/</a></p></blockquote><h1 id="使用overlay网络"><a href="#使用overlay网络" class="headerlink" title="使用overlay网络"></a>使用overlay网络</h1><p><code>overlay</code>网络驱动程序在多个Docker守护程序主机之间创建分布式网络。该网络位于（overlays）特定于主机的网络之上，允许连接到它的容器（包括swarm service）安全地通信。Docker透明地处理每个数据包与正确的Docker守护程序主机和正确的目标容器的路由。</p><p>当你初始化一个swarm或者使一个Docker主机加入一个已经存在的swarm，将会在Docker主机新建两个网络。</p><ul><li>一个称作<code>ingress</code>的overlay网络，用于处理与swarm services相关的控制和数据流量。当你创建一个swarm service并且不将其连到到一个用户自定义的overlay网络时，默认情况下它会连接到<code>ingress</code>网络。</li><li>一个是称作<code>docker_gwbridge</code>的桥接网络，用于将各个Docker守护进程连接到加入swarm的其他守护进程。</li></ul><p>你可以使用<code>docker network create</code>命令创建用户自定义的<code>overlay</code>网络，利用同样的方法你可以创建用户自定义的<code>bridge</code>网络。服务或容器可以一次连接超过一个网络。服务或容器只能通过它们各自连接的网络进行通信。</p><p>虽然你可以将swarm services和独立容器连接到覆盖网络，但默认特性（表现、行为）和配置问题是不同的。因此，本主题的其余部分分为适用于所有overlay网络的操作，适用于swarm service网络的操作以及适用于独立容器使用的覆盖网络的操作。</p><h2 id="所有overlay网络的操作"><a href="#所有overlay网络的操作" class="headerlink" title="所有overlay网络的操作"></a>所有overlay网络的操作</h2><h3 id="创建一个overlay网络"><a href="#创建一个overlay网络" class="headerlink" title="创建一个overlay网络"></a>创建一个overlay网络</h3><blockquote><p><strong>先决条件：</strong></p><ul><li>Docker守护进程的防火墙规则使用overlay网络在overlay网络上，使每个参加overlay网络的Docker主机能够相互通信，你需要开放以下端口。<ul><li>用于集群管理通信的TCP 2377端口</li><li>用于节点之间通信的TCP、UDP 7946端口</li><li>用于overlay网络流量传输的UDP 4789端口</li></ul></li><li>在创建overlay网络之前，你需要使用<code>docker swarm init</code>初始化你的Docker守护进程为一个swarm manager，或者使用<code>docker swarm join</code>将Docker守护进程连接到一个现有的swarm。这些中的任何一个都会创建默认的<code>ingress</code> overlay网络，默认情况下由swarm service使用。即使你从未计划使用swarm services，也需要执行此操作。之后，你可以另外创建用户自定义的overlay网络。</li></ul></blockquote><p>要创建于swarm services的overlay网络，使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create -d overlay my-overlay</span><br></pre></td></tr></table></figure><p>要创建可由swarm services或独立容器用于与在其他Docker守护程序上运行的其他独立容器通信的overlay网络，请添加<code>--attachable</code>参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create -d overlay --attachable my-attachable-overlay</span><br></pre></td></tr></table></figure><p>你可以指定IP地址范围、子网、网关和其他选项。有关详细信息，请参阅<code>docker network create --help</code>。</p><h3 id="加密overlay网络上的流量"><a href="#加密overlay网络上的流量" class="headerlink" title="加密overlay网络上的流量"></a>加密overlay网络上的流量</h3><p>默认情况下，所有swarm service管理流量都已加密，在GCM模式下使用<a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode" target="_blank" rel="noopener">AES算法</a>。swarm中的管理者节点每隔12小时轮换用于加密gossip data的密钥。</p><p>要加密应用程序数据，请在创建overlay网络时添加<code>--opt encrypted</code>。这样可以在vxlan级别启用IPSEC加密。此加密会带来不可忽视的性能损失，因此你应该在生产中使用此选项之前对其进行测试。</p><p>当你启用overlay加密时，Docker会在所有节点之间创建IPSEC隧道，在这些节点上为连接到overlay网络的服务安排任务。这些隧道也是在GCM模式下使用AES算法，管理者节点每12小时自动轮换密钥。</p><blockquote><p><strong>不要将Windows节点连接到加密的overlay网络。</strong></p><p>Overlay网络在Windows上不支持加密。如果Windows节点尝试连接到加密的overlay网络，则不会检测到错误，但节点无法通信。</p></blockquote><h3 id="swarm模式overlay网络和独立容器"><a href="#swarm模式overlay网络和独立容器" class="headerlink" title="swarm模式overlay网络和独立容器"></a>swarm模式overlay网络和独立容器</h3><p>你可以将overlay网络功能与<code>--opt encrypted --attachable</code>一起使用，并且附加非托管容器到该网络：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create --opt encrypted --driver overlay --attachable my-attachable-multi-host-network</span><br></pre></td></tr></table></figure><h3 id="自定义默认的ingress网络"><a href="#自定义默认的ingress网络" class="headerlink" title="自定义默认的ingress网络"></a>自定义默认的ingress网络</h3><p>大多数用户从不需要配置<code>ingress</code>网络，但Docker 17.05及更高版本允许你这样做。如果自动选择的子网与网络上已存在的子网冲突，或者你需要自定义其他低层网络设置（如MTU），则此功能非常有用。</p><p>自定义<code>ingress</code>网络涉及删除和重新创建它。这通常是你在swarm中创建任何服务之前完成。如果你具有发布端口的现有服务，则需要先删除这些服务，然后才能删除<code>ingress</code>网络。</p><p>在不存在<code>ingress</code>网络的期间，现有的服务不发布端口继续运行，但不是负载平衡的。这会影响发布端口的服务，例如发布80端口的WordPress服务。</p><ol><li><p>使用<code>docker network inspect ingress</code>检查<code>ingress</code>网络，并且删除所有连接到其的服务。这些是发布端口的服务，例如发布80端口的WordPress服务。如果所有这些服务都没有停止，那么下一步会失败。</p></li><li><p>删除现有的<code>ingress</code>网络：</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker network rm ingress</span><br><span class="line"></span><br><span class="line">WARNING! Before removing the routing-mesh network, make sure all the nodes</span><br><span class="line"><span class="keyword">in</span> your swarm run the same docker engine version. Otherwise, removal may not</span><br><span class="line">be effective and functionality of newly created ingress networks will be</span><br><span class="line">impaired.</span><br><span class="line">Are you sure you want to <span class="built_in">continue</span>? [y/N]</span><br></pre></td></tr></table></figure><ol start="3"><li>使用<code>--ingress</code>参数创建一个新的overlay网络，以及要设置的自定义选项。此示例将MTU设置为1200，将子网设置为<code>10.11.0.0/16</code>，并将网关设置为<code>10.11.0.2</code>。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create \</span><br><span class="line">  --driver overlay \</span><br><span class="line">  --ingress \</span><br><span class="line">  --subnet=10.11.0.0/16 \</span><br><span class="line">  --gateway=10.11.0.2 \</span><br><span class="line">  --opt com.docker.network.driver.mtu=1200 \</span><br><span class="line">  my-ingress</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> 你可以命名你的<code>ingress</code>网络除（名为）<code>ingress</code>之外，你只能拥有一个<code>ingress</code>网络。尝试创建第二个会失败。</p></blockquote><ol start="4"><li>重新启动你在第一步中停止的服务。</li></ol><h3 id="自定义docker-gwbridge接口"><a href="#自定义docker-gwbridge接口" class="headerlink" title="自定义docker_gwbridge接口"></a>自定义docker_gwbridge接口</h3><p><code>docker_gwbridge</code>是一个将overlay网络（包括<code>ingress</code>网络）连接到个人Docker守护进程的物理网络的虚拟网桥。Docker会在你初始化一个swarm或者在连接一个Docker主机到swarm的时候自动地它，但它不是一个Docker设备。它存在于Docker主机的内核中。如果你需要自定义其设置，你必须在Docker主机加入swarm之前或者暂时从swarm删除主机之后执行此操作。</p><ol><li>停止Docker。</li><li>删除现存的<code>docker_gwbridge</code>接口</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ip link <span class="built_in">set</span> docker_gwbridge down</span><br><span class="line">$ sudo ip link del dev docker_gwbridge</span><br></pre></td></tr></table></figure><ol start="3"><li>启动Docker。不要连接（加入）或者初始化swarm。</li><li>使用<code>docker network create</code>命令根据你的自定义设置手动创建或者重建<code>docker_gwbridge</code>网桥。这个例子使用<code>10.11.0.0/16</code>子网。有关可自定义选项的完整列表，请参阅<a href="https://docs.docker.com/engine/reference/commandline/network_create/#bridge-driver-options" target="_blank" rel="noopener">Bridge driver options</a>。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create \</span><br><span class="line">--subnet 10.11.0.0/16 \</span><br><span class="line">--opt com.docker.network.bridge.name=docker_gwbridge \</span><br><span class="line">--opt com.docker.network.bridge.enable_icc=<span class="literal">false</span> \</span><br><span class="line">--opt com.docker.network.bridge.enable_ip_masquerade=<span class="literal">true</span> \</span><br><span class="line">docker_gwbridge</span><br></pre></td></tr></table></figure><ol start="5"><li>初始化或者连接（加入）swarm，由于桥已经存在，Docker不会使用自动设置创建它。</li></ol><h2 id="swarm-services的操作"><a href="#swarm-services的操作" class="headerlink" title="swarm services的操作"></a>swarm services的操作</h2><h3 id="在overlay网络发布端口"><a href="#在overlay网络发布端口" class="headerlink" title="在overlay网络发布端口"></a>在overlay网络发布端口</h3><p>Swarm services连接到同样的overlay网络会有效地将所有端口相互暴露。对于可在服务外部访问的端口，这个端口必须在<code>docker service create</code>或者<code>docker service update</code>中使用<code>-p</code>或者<code>--publish</code>参数。支持“遗留”的冒号分隔的语法和较新的逗号分隔值语法。较长的语法是首选，因为它有点自我文档化（what?）。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-p 8080:80 or -p published=8080,target=80</td><td>将服务上的TCP 80端口映射到routing mesh上的8080端口。</td></tr><tr><td>-p 8080:80/udp or -p published=8080,target=80,protocol=udp</td><td>将服务上的UDP 80端口映射到routing mesh上的8080端口。</td></tr><tr><td>-p 8080:80/tcp -p 8080:80/udp or -p published=8080,target=80,protocol=tcp -p published=8080,target=80,protocol=udp</td><td>将服务上的TCP 80端口映射到routing mesh上的TCP 8080端口，并将服务上的UDP 80端口映射到routing mesh上的UDP 8080端口。</td></tr></tbody></table><h3 id="绕过swarm-service的routing-mesh"><a href="#绕过swarm-service的routing-mesh" class="headerlink" title="绕过swarm service的routing mesh"></a>绕过swarm service的routing mesh</h3><p>默认情况下，发布端口的swarm services使用路由网格来实现。当你连接到任何swarm节点上已经发布的端口（无论它是否正在运行给定服务）时，你将被透明地重定向到正在运行该服务的工作线程。实际上，Docker充当你的swarm services的负载均衡器。使用routing mesh的服务以virtual IP（VIP）模式运行。甚至在每个节点上运行的服务（通过–mode全局标志）也使用routing mesh。当使用routing mesh，无法保证哪个Docker节点服务客户端请求。</p><p>要绕过routing mesh，可以使用DNS循环（DNSRR）模式，通过设置<code>--endpoint-mode</code>参数为<code>dnsrr</code>启动服务。你必须在服务之前运行你自己的负载均衡器。Docker主机上的服务名称的DNS查询返回运行该服务的节点的IP地址列表。配置负载均衡器以使用此列表并平衡节点之间的流量。</p><h3 id="分离控制和数据流量"><a href="#分离控制和数据流量" class="headerlink" title="分离控制和数据流量"></a>分离控制和数据流量</h3><p>默认情况下，尽管群集控制流量已加密，但控制与swarm管理相关的流量以及流入和流出应用程序的流量都在同一网络上运行。你可以配置Docker使用独立的网络接口去处理这两种不同类型的流量。当你初始化或者连接（加入）swarm时，分别指定<code>--advertise-addr</code>和<code>--datapath-addr</code>。你必须为每个连接swarm的节点执行此操作。</p><h2 id="swarm网络上独立容器的操作"><a href="#swarm网络上独立容器的操作" class="headerlink" title="swarm网络上独立容器的操作"></a>swarm网络上独立容器的操作</h2><h3 id="将独立容器连接到swarm网络"><a href="#将独立容器连接到swarm网络" class="headerlink" title="将独立容器连接到swarm网络"></a>将独立容器连接到swarm网络</h3><p><code>ingress</code>网络在创建时不使用<code>--attachable</code>参数，意味着只有swarm services可以使用它，而不是独立容器。你可以将独立容器连接到创建时使用<code>--attachable</code>参数的用户自定义的overlay网络。这使得在不同Docker守护程序上运行的独立容器能够进行通信，而无需在各个Docker守护程序主机上设置路由。</p><h3 id="发布端口"><a href="#发布端口" class="headerlink" title="发布端口"></a>发布端口</h3><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-p 8080:80</td><td>将容器上的TCP 80端口映射到overlay网络上的8080端口。</td></tr><tr><td>-p 8080:80/udp</td><td>将容器上的UDP 80端口映射到overlay网络上的8080端口。</td></tr><tr><td>-p 8080:80/sctp</td><td>将容器上的STCP 80端口映射到overlay网络上的STCP 8080端口</td></tr><tr><td>-p 8080:80/tcp -p 8080:80/udp</td><td>将容器上的TCP 80端口映射到overlay网络上的TCP 8080端口，并将容器上的UDP 80端口映射到overlay网络上的UDP 8080端口。</td></tr></tbody></table><h3 id="容器发现"><a href="#容器发现" class="headerlink" title="容器发现"></a>容器发现</h3><p>对于大多数情况，你应该连接到服务名称，该名称是负载平衡的，并由支持该服务的所有容器（“tasks”）处理。要获取支持该服务的所有任务的列表，请执行DNS查找<code>tasks.&lt;service-name&gt;</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
            <tag> translation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>record the experience of converting image formats</title>
      <link href="/2019-02/record-the-experience-of-converting-image-formats/"/>
      <url>/2019-02/record-the-experience-of-converting-image-formats/</url>
      
        <content type="html"><![CDATA[<p>因有一批CR2格式（RAW）的图片需要转换为jpg格式。因为电脑上没有安装相关的软件，所有就计划利用现有的“开发环境”来自己写一个格式转换的脚本进行自动的批量转换。</p><a id="more"></a><p>首先想到的就是python，经过一番搜索，决定先试下PIL（Python Image Library）这个图像处理库。PIL目前还未有python3的版本，PIL相关下载请参阅<a href="http://pythonware.com/products/pil/" target="_blank" rel="noopener">PIL下载页面</a></p><p><img src="/2019-02/record-the-experience-of-converting-image-formats/20190210_pil_down_page.png" alt>▲ PIL下载页面</p><p>现在有个叫Pillow（号称friendly fork for PIL，下文简称PIL）移植版本，功能据说是和PIL基本一样，不过它支持python3，请参阅<a href="https://pillow.readthedocs.io/en/stable/index.html" target="_blank" rel="noopener">Pillow文档</a>。</p><p>安装Pillow</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install pillow</span><br></pre></td></tr></table></figure><p>一个测试脚本，打开CR2格式的图片，打印图片信息并以jpg格式保存图片。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line"><span class="comment"># 打开图像文件</span></span><br><span class="line">pic = <span class="string">"bb.CR2"</span></span><br><span class="line">img = Image.open(pic)</span><br><span class="line"><span class="built_in">print</span>(img)</span><br><span class="line"><span class="comment"># 以jpg格式保存:</span></span><br><span class="line">img.save(<span class="string">'new.jpg'</span>, <span class="string">'jpeg'</span>)</span><br></pre></td></tr></table></figure><p>执行脚本，报错了，<code>OSError: cannot identify image file &#39;xx.CR2&#39;</code>。</p><p><img src="/2019-02/record-the-experience-of-converting-image-formats/20190210_pil_cr2.png" alt>▲ PIL打开CR2文件报错</p><p>后面多次尝试结果都一样，于是便用一个jpg文件测试一下，结果是可以正常执行的。</p><p><img src="/2019-02/record-the-experience-of-converting-image-formats/20190210_pil_jpg.png" alt>▲ PIL正常打开jpg文件</p><p>于是猜想会不会是PIL不支持CR2（RAW）格式的图片，查阅了下相关资料，并未发现CR2，请参阅<a href="https://pillow.readthedocs.io/en/stable/handbook/image-file-formats.html" target="_blank" rel="noopener">PIL所支持的格式列表</a>。</p><p>利用PIL将CR2文件转换为jpg文件的方法到此结束。</p><p>接着我找到了一个可以处理RAW文件的rawkit库，<a href="https://rawkit.readthedocs.io/en/v0.6.0/index.html" target="_blank" rel="noopener">rawkit主页</a>。</p><p>这样利用rawkit就可以读取CR2格式图片，不过rawkit主要功能是对RAW文件数据的调整，并没有提供格式转换的功能。不过前面提到的PIL库中的<code>frombytes</code>模块可以将图片数据生成图片文件（官方解释：<strong>Creates a copy of an image memory from pixel data in a buffer.</strong>），请参阅<a href="https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.frombytes" target="_blank" rel="noopener">PIL.Image.formbytes</a>。不过中间还需要利用<code>numpy</code>库，对读取出来的RAW文件的数据进行一些处理。</p><p>大概流程：</p><ol><li>利用rawkit打开RAW文件</li><li>可以利用rawkit对RAW文件的数据对图片效果进行一些调整（可选）</li><li>利用numpy处理RAW文件数据</li><li>利用PIL将相关数据生成图片文件数据（内存）</li><li>利用PIL将内存中的图片数据保存为指定格式的图片文件</li></ol><p>经测试，方法可行，于是整理脚本，对CR2文件进行批量的格式转换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> rawkit.raw <span class="keyword">import</span> Raw</span><br><span class="line"><span class="keyword">from</span> rawkit.options <span class="keyword">import</span> WhiteBalance, colorspaces, gamma_curves, highlight_modes</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">fils = os.listdir(<span class="string">"/root/CR2_dir/"</span>)</span><br><span class="line">source = <span class="string">"/root/CR2_dir/"</span></span><br><span class="line">target = <span class="string">"/root/JPG_dir/"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> fina <span class="keyword">in</span> fils:</span><br><span class="line">    print(target+re.sub(<span class="string">r'.CR2'</span>,<span class="string">".jpg"</span>,fina))</span><br><span class="line"></span><br><span class="line">    raw_image = Raw(source+fina)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 下面对RAW数据的调整是后面加上的</span></span><br><span class="line">    <span class="comment"># raw_image.options.white_balance = WhiteBalance(camera=False,auto=True)</span></span><br><span class="line">    <span class="comment"># raw_image.options.colorspace = colorspaces.adobe_rgb</span></span><br><span class="line">    <span class="comment"># raw_image.options.gamma = gamma_curves.adobe_rgb</span></span><br><span class="line">    <span class="comment"># raw_image.options.highlight_mode = highlight_modes.blend</span></span><br><span class="line">    <span class="comment"># raw_image.options.highlight_mode = highlight_modes.reconstruct</span></span><br><span class="line"></span><br><span class="line">    buffered_image = np.array(raw_image.to_buffer())</span><br><span class="line"></span><br><span class="line">    image = Image.frombytes(<span class="string">'RGB'</span>, (raw_image.metadata.width, raw_image.metadata.height), buffered_image)</span><br><span class="line">    image.save(target+re.sub(<span class="string">r'.CR2'</span>,<span class="string">".jpg"</span>,fina))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"---------------[END]------------------"</span>)</span><br></pre></td></tr></table></figure><p>运行脚本。</p><p><img src="/2019-02/record-the-experience-of-converting-image-formats/20190210_pil_rawkit.png" alt>▲ 利用rawkit-numpy-PIL批量转换CR2文件格式</p><p>不过，最后查看转换后的图片时，却发现了一个奇怪的问题。</p><p><img src="/2019-02/record-the-experience-of-converting-image-formats/20190210_cr2_jpg.png" alt>▲ 转换的jpg比原CR2的亮度要低</p><p>转换格式后的图片的样式变了，我想应该是RAW文件数据处理的问题，便参考rawkit的文档，调整了几个数据，虽然有些许变化，不过都没能达到原CR2文件预览的效果。</p><p>当下我还不想成为一个“图片数据、参数专家”，所以利用rawkit-numpy-PIL这个组合的方法，到此结束。</p><p>不过，在上面所说的这些方法之前，已经发现Windows 10上面的<code>照片</code>自带有一个“保存副本”的功能，利用这个可以将CR2文件保存为jpg格式，而且转换后的图片和CR2预览的效果基本一样。</p><p><img src="/2019-02/record-the-experience-of-converting-image-formats/20190210_win_pic.png" alt>▲ 利用Windows 10的<code>照片</code>“保存副本”转换图片格式</p><p>于是乎，我又打算从这里入手。当然，因为图片的数量问题，是不可能一个一个的手动操作进行转换的。好在可以利用python进行一个点击、按键的模拟。这样可以写一个“自动化”的脚本，让电脑替代人工来完成这类大量的简单重复操作。</p><p>python在Windows上面要实现点击之类的模拟，需要pywin32库，利用它，python可以调用一些Windows上面的接口。请参阅<a href="https://github.com/mhammond/pywin32" target="_blank" rel="noopener">pywin32的Github</a>。</p><p>可以将保存副本的操作步骤都记录下来，知道每次点击的像素位置，然后用python的模拟点击进行自动批量操作。因为Windows 10上面的<code>照片</code>刚好支持快捷键，所用这里用更简单的模拟按键的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> win32api,win32gui,win32con</span><br><span class="line"></span><br><span class="line">VK_CODE = &#123;</span><br><span class="line">    <span class="string">'ctrl'</span>:<span class="number">0x11</span>,</span><br><span class="line">    <span class="string">'right_arrow'</span>:<span class="number">0x27</span>,</span><br><span class="line">    <span class="string">'enter'</span>:<span class="number">0x0D</span>,</span><br><span class="line">    <span class="string">'e'</span>:<span class="number">0x45</span>,</span><br><span class="line">    <span class="string">'s'</span>:<span class="number">0x53</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendKeys</span><span class="params">(a,b,t)</span>:</span></span><br><span class="line">    win32api.keybd_event(VK_CODE[a], <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    win32api.keybd_event(VK_CODE[b], <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    time.sleep(t)</span><br><span class="line">    win32api.keybd_event(VK_CODE[a], <span class="number">0</span>, win32con.KEYEVENTF_KEYUP, <span class="number">0</span>)</span><br><span class="line">    win32api.keybd_event(VK_CODE[b], <span class="number">0</span>, win32con.KEYEVENTF_KEYUP, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendKey</span><span class="params">(a)</span>:</span></span><br><span class="line">    win32api.keybd_event(VK_CODE[a], <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    win32api.keybd_event(VK_CODE[a], <span class="number">0</span>, win32con.KEYEVENTF_KEYUP, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dokey</span><span class="params">()</span>:</span></span><br><span class="line">    sendKeys(<span class="string">"ctrl"</span>,<span class="string">"e"</span>,<span class="number">0.1</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    sendKeys(<span class="string">"ctrl"</span>,<span class="string">"s"</span>,<span class="number">0.1</span>)</span><br><span class="line">    time.sleep(<span class="number">1.5</span>)</span><br><span class="line">    sendKey(<span class="string">"enter"</span>)</span><br><span class="line">    time.sleep(<span class="number">3.5</span>)</span><br><span class="line">    sendKey(<span class="string">"right_arrow"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    total = int(input(<span class="string">"input total picture: "</span>))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"please a number."</span>)</span><br><span class="line">    exit();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,total):</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"["</span>+str(i+<span class="number">1</span>)+<span class="string">"/"</span>+str(total)+<span class="string">"]"</span>)</span><br><span class="line">    dokey()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"----------------[END]--------------------"</span>)</span><br></pre></td></tr></table></figure><p><img src="/2019-02/record-the-experience-of-converting-image-formats/20190210_pywin.gif" alt>▲ 模拟按键“自动操作”</p><p>利用这类方法的缺点就是，需要自己根据实际调整每个步骤的时间间隔，还有在执行时，电脑不能用来做其他的事情。</p><p>最后总结，如果不是特别需求，最省事的方法是直接用专门的格式转换工具进行处理。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> picture </tag>
            
            <tag> formats </tag>
            
            <tag> automation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>deploy github pages with Travis-CI automation</title>
      <link href="/2019-02/deploy-github-pages-with-travis-ci-automation/"/>
      <url>/2019-02/deploy-github-pages-with-travis-ci-automation/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>目前博客用的是hexo，github pages默认只对jekyll有转换原始文件（md）为静态文件的支持。所以，hexo需要在本地将原始文件转换成静态文件，然后在hexo d部署上去。</p><p>看到了Travis-CI，对此了解了下，并对原来的文章部署方式做了一下“升级”。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">hexo clean &amp;&amp; hexo d &amp;&amp; hexo clean</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"update: <span class="variable">$(date)</span>"</span></span><br><span class="line">git push origin hexo_uni</span><br></pre></td></tr></table></figure><p>上面是我原本“一键部署文章”的脚本，大致上分两个部分，生成并部署静态文件，还有push上传原始文件。</p><p>如果利用Travis-CI的话，自己手上的工作就只有push上传原始文件，而静态文件的生成和部署则全部交给Travis-CI处理，这个效果其实和jekyll基本是一样的了。这样一来我现在的“一键部署文章”的脚本就只需要下面的内容（就是一次普通的git操作）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"update: <span class="variable">$(date)</span>"</span></span><br><span class="line">git push origin hexo_uni</span><br></pre></td></tr></table></figure><p>原来要想在另一台电脑上写作，除了要将原文件从仓库clone下来，还得安装node环境等。现在只要求一台联网并安装git的电脑，就可以上手写作并部署文章。（当然，想要本地预览，还是得安装node等相关环境）</p><h2 id="Travis-CI"><a href="#Travis-CI" class="headerlink" title="Travis-CI"></a>Travis-CI</h2><blockquote><p>Travis-CI目前只支持github</p></blockquote><ul><li><a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis-CI org官网</a></li><li><a href="https://docs.travis-ci.com/user/for-beginners/" target="_blank" rel="noopener">Travis-CI 文档的说明</a></li></ul><p>利用Travis-CI可以在项目更新时（比如将本地更新后的代码push到github）自动化的处理、执行一些原本需要开发人员手动操作的工作。</p><p>按原本的开发-测试-部署流程，每次的项目更新都意味着需要在运行环境中进行新一轮的测试、部署。如果是频繁的小更新，而每次都得从头的一步一步的在运行环境中部署，显然是个很“艰难”的过程。大多数人应该都会选择将多个的小更新积累成一个相对大的“版本”再统一部署，也不会选择每次为了一个小小的改动而频繁去做繁重的部署工作。如果利用Travis-CI，那么开发人员只需要关心项目的更新，项目的部署工作则全由Travis-CI处理。这样哪怕再频繁的小更新，都能很轻松的（自动部署）看到项目最终的运行效果。</p><p>这些将Travis-CI里的“自动部署”的关键词用上。</p><h2 id="配置Travis-CI的大概流程"><a href="#配置Travis-CI的大概流程" class="headerlink" title="配置Travis-CI的大概流程"></a>配置Travis-CI的大概流程</h2><h3 id="生成token"><a href="#生成token" class="headerlink" title="生成token"></a>生成token</h3><p>可以先在github上面生成一个token，用于Travis-CI端向github部署时的认证凭证。</p><p>github生成token的步骤请参阅<a href="https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/" target="_blank" rel="noopener">Creating a personal access token for the command line</a>。</p><p><img src="/2019-02/deploy-github-pages-with-travis-ci-automation/2019-02-01_create_token.png" alt>▲ 在生成token时，只给接入（读写）权限就可以了</p><h3 id="登录Travis-CI"><a href="#登录Travis-CI" class="headerlink" title="登录Travis-CI"></a>登录Travis-CI</h3><p>在Travis-CI org官网登录（用github账号直接登录）。</p><p><img src="/2019-02/deploy-github-pages-with-travis-ci-automation/2019-02-01_travis_ci_index.png" alt>▲ Travis-CI主页</p><h3 id="同步仓库"><a href="#同步仓库" class="headerlink" title="同步仓库"></a>同步仓库</h3><p>在Travis-CI同步github仓库（如果没自动同步则手动同步）。</p><h3 id="激活仓库"><a href="#激活仓库" class="headerlink" title="激活仓库"></a>激活仓库</h3><p>激活要配置Travis-CI的仓库。</p><p><img src="/2019-02/deploy-github-pages-with-travis-ci-automation/2019-02-01_active_repo.png" alt>▲ 激活github pages仓库</p><h3 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h3><p>在Travis-CI进入仓库的控制台，添加token的环境变量。</p><p>不希望公开的环境变量可以在控制台添加，如果只是普通的变量可以直接写在yml文件。</p><p><img src="/2019-02/deploy-github-pages-with-travis-ci-automation/2019-02-01_set_token.png" alt>▲ value是前面第1步生成的token，可以选择在build log中不显示</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>现在Travis-CI的基本配置已经完成了，如果还有其他的需要，请参阅<a href="https://docs.travis-ci.com/" target="_blank" rel="noopener">Travis-CI的文档</a>。</p><p>需要注意的是，Travis-CI有商业版和社区版之分，其中商业版是收费的，这是讲的是免费的社区版。商业版的Travis-CI主页网址是以<strong>com</strong>结尾，社区版为<strong>org</strong>，两个网站的风格基本是一样的，不过两个并不相通，需要独立配置。还有社区版的文档导向的是商业版的参阅文档，如果在从文档的网页直接点跳转回主页，到达的是社区版的主页，需要留意下。</p><h2 id="配置-travis-yml文件，自动化部署github-pages"><a href="#配置-travis-yml文件，自动化部署github-pages" class="headerlink" title="配置.travis.yml文件，自动化部署github pages"></a>配置.travis.yml文件，自动化部署github pages</h2><p>.travis.yml需要放在项目的根目录。在项目新时便会触发Travis-CI，Travis-CI会根据.travis.yml文件的配置内容执行。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定语言环境</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="comment"># 指定版本，这个个人建议最好加上，因为不同的node版本所对应的hexo插件版本可能也不一样、不兼容，</span></span><br><span class="line"><span class="comment"># 因为配置环境时的npm install是从定死的package.json文件中的依赖列表中的条目下载的，</span></span><br><span class="line"><span class="comment"># 如果版本不一样，则很大机率会失败</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="number">10.8</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缓存node_modules文件夹，下次build时可以快些</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  directories:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">node_modules</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># S: Build Lifecycle</span></span><br><span class="line"><span class="comment"># 安装环境</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">export</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成静态文件</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将生成的静态文件部署到github，</span></span><br><span class="line"><span class="comment"># 因为原本的hexo d是通过ssh或者手动输入用户信息进行认证的，在Travis-CI再用这种方法会比较麻烦，有其他更简单的方法代替，如token，</span></span><br><span class="line"><span class="comment"># 因为只需要将生成的静态内容部署到github，所以就不能在原有仓库（源码仓库）的基础上上传，推荐两个方法：</span></span><br><span class="line"><span class="comment"># 1. 常规方式：</span></span><br><span class="line"><span class="comment"># 在生成的静态文件的文件夹内新初始化一个仓库，在强制push到github的pages主分支，之所以要强制，</span></span><br><span class="line"><span class="comment"># 是因为这种文件每次的部署都是将一个新的仓库部署上去，版本号冲突是一定的。</span></span><br><span class="line"><span class="comment"># 这种方法是直接用git cli，可以将所有的命令写到yml的script。</span></span><br><span class="line"><span class="comment"># 这种方法的缺点是不能保留静态文件的commit记录（其实也不重要）。</span></span><br><span class="line"><span class="comment"># 2. Travis-CI提供的快捷部署方式：</span></span><br><span class="line"><span class="comment"># 也就是个人目前用的方法，如下</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  provider:</span> <span class="string">pages</span></span><br><span class="line"><span class="attr">  skip-cleanup:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 在Travis-CI控制台设置的token环境变量</span></span><br><span class="line"><span class="attr">  github-token:</span> <span class="string">$&#123;GH_TOKEN&#125;</span></span><br><span class="line"><span class="attr">  keep-history:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 可选，github用户名</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">unihon</span></span><br><span class="line">  <span class="comment"># 可选，github邮箱</span></span><br><span class="line"><span class="attr">  email:</span> <span class="string">unihon@outlook.com</span></span><br><span class="line">  <span class="comment"># 如果是用同一个仓库的两个分支分别存放源文件和静态文件，local-dir和target-branch是必选</span></span><br><span class="line">  <span class="comment"># 要上传的静态文件的路径</span></span><br><span class="line"><span class="attr">  local-dir:</span> <span class="string">./public</span></span><br><span class="line">  <span class="comment"># 将local-dir指定的文件（静态文件）上传到的分支，也就是pages分支</span></span><br><span class="line"><span class="attr">  target-branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="comment"># 工作分支，也就是你仓库源码的分支</span></span><br><span class="line"><span class="attr">  on:</span></span><br><span class="line"><span class="attr">    branch:</span> <span class="string">hexo_uni</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当hexo_uni分支更新时触发</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">hexo_uni</span></span><br></pre></td></tr></table></figure><p>github pages快捷部署的详细说明请参阅<a href="https://docs.travis-ci.com/user/deployment/pages/" target="_blank" rel="noopener">github pages快捷部署方式官方文档</a>。</p><h2 id="查看Travis-CI的build情况"><a href="#查看Travis-CI的build情况" class="headerlink" title="查看Travis-CI的build情况"></a>查看Travis-CI的build情况</h2><p>在仓库更新时，就会触发Travis-CI。因为Travis-CI每次的build过程都是从一个新的环境开始，所以需要一点时间（具体时间因项目内容而定）。</p><p><img src="/2019-02/deploy-github-pages-with-travis-ci-automation/2019-02-01_build.png" alt>▲ 项目更新后，在Travis-CI控制台查看build情况。</p><p>在控制台可以查看build仓库的相关以及build的日志，日志中有构建过程中每一步的信息。</p><p><img src="/2019-02/deploy-github-pages-with-travis-ci-automation/2019-02-01_build_error.png" alt>▲ build失败（com例子）</p><p><img src="/2019-02/deploy-github-pages-with-travis-ci-automation/2019-02-01_mail.png" alt>▲ 通知邮件（com例子）</p><p>如果buidl失败会有邮件通知，邮件中也会有相关日志信息，方便排除问题。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://docs.travis-ci.com/" target="_blank" rel="noopener">https://docs.travis-ci.com/ </a></li><li><a href="https://blog.csdn.net/duzilonglove/article/details/79012499" target="_blank" rel="noopener">https://blog.csdn.net/duzilonglove/article/details/79012499 </a> </li><li><a href="https://molunerfinn.com/hexo-travisci-https/" target="_blank" rel="noopener">https://molunerfinn.com/hexo-travisci-https/ </a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Tranvis-CI </tag>
            
            <tag> github-pages </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[docker] use bridge networks</title>
      <link href="/2019-01/docker-use-bridge-networks/"/>
      <url>/2019-01/docker-use-bridge-networks/</url>
      
        <content type="html"><![CDATA[<blockquote><p>【翻译】相关声名：<a href="https://unihon.github.io/2019-01/statement-of-some-blog-articles/">https://unihon.github.io/2019-01/statement-of-some-blog-articles/</a></p></blockquote><a id="more"></a><blockquote><p>Docker v18.09<br>Configure networking<br>Use bridge networks<br>原文链接：<a href="https://docs.docker.com/network/bridge/" target="_blank" rel="noopener">https://docs.docker.com/network/bridge/</a></p></blockquote><h1 id="使用桥接网络"><a href="#使用桥接网络" class="headerlink" title="使用桥接网络"></a>使用桥接网络</h1><p>在网络方面，桥接网络是一个网段之内转发流量的链路层设备。网桥可以是一个硬件设备或者是一个运行在主机核心内的软件设备。<br>在Docker方面，桥接网络使用软件网桥，允许容器连接到同一个网桥网格进行通信。当容器需要提供隔离时便不需要连接到这个网桥。Docker的网桥驱动自动将相关的规则、配置安装在主机，这样容器在不同的桥接网络不允许彼此直接通信。</p><p>桥接网络适用于在同一个Docker守护程序主机上运行的容器。对于在不同Docker守护程序主机上运行的容器之间的通信，您可以在操作系统级别管理路由，也可以使用overlay网络。</p><p>当你启动Docker，默认桥接网络（也称作网桥）将会被自动创建，除非另有规定，否则新启动的容器将连接到此网桥。你也可以创建用户自定义的桥接网络。用户自定义的桥接网络更优于默认网桥（生产环境中更适用）。</p><h2 id="用户自定义网桥和默认网桥的差异"><a href="#用户自定义网桥和默认网桥的差异" class="headerlink" title="用户自定义网桥和默认网桥的差异"></a>用户自定义网桥和默认网桥的差异</h2><ul><li><p>用户自定义的网桥可在容器应用之间提供更好的隔离和互操作性。</p><p>  连接到同一用户定义的网桥的容器会自动将所有端口相互暴露，并且不会向外界开放任何端口。这使得容器化应用程序可以轻松地相互通信，而不会意外地打开对外界的访问。</p><p>  想象一个具有Web前端和数据库后端的应用程序。外部环境需要访问Web前端（可能通过80端口），但只有后端自身需要访问数据库主机和端口。使用用户自定义的网桥，只有Web端口需要被开放，同时数据库应用不需要开放任何的端口，因为Web前端可以通过用户自定义的网格访问到它。</p><p>  如果在默认桥接网络上运行相同的应用程序堆栈，需要同时都开放Web端口和数据库的端口，为每个应用使用 <code>-p</code>或者<code>--publish</code>参数。这意味着Docker主机需要通过其他手段阻止对数据库的端口的访问。</p></li><li><p>用户自定义网桥为容器之间提供的自动DNS解析</p><p>  在默认桥接网络，容器仅能通过IP地址相互访问，除非你使用<code>--link</code>参数，这是一个遗留的参数。在用户自定义桥接网络，容器可以通过名字或者别名相互解析。</p><p>  想象有一个与上面所提同样的应用，有一个Web前端和一个数据库后台。假设称这两个容器为web和db，无论在哪个Docker主机上面运行应用程序堆栈，web容器都可以访问到db容器。</p><p>  如果是在默认桥接网络运行同样的应用程序堆栈，需要在容器之间手动创建链路（使用<code>--link</code>参数），每个容器都需要创建这些链路。正如你所见，如果超出两个容器需要相互通信，这将变得复杂起来。另外，你可以操作容器内的<code>/etc/hosts</code>文件，但这创建的问题是难于调试（debug）。</p></li><li><p>容器在运行时可以与用户自定义网络附加和分离。</p><p>  在容器的生命周期，你可以从用户自定义的网络将运行中的容器连接或者断开。从默认桥接网络中删除容器，你需要停止容器并使用不同的网络参数重新创建（启动）它。</p></li><li><p>每个用户自定义网络可以创建一个可配置网桥。</p><p>  如果你的容器使用默认桥接网络，你可以配置它，但是所有所用默认桥接网络的容器都将会使用同样的设置，比如MTU和<code>iptables</code>的规则。另外，配置默认桥接网络是发生在Docker自身之外，要使修改后的配置生效需要将Docker重启。</p><p>  用户自定义桥接网络使用<code>docker network create</code>创建和配置。如果应用的不同组有不同的网络需求，当你创建网桥时，可以分别为每一个用户自定义网桥进行配置。</p></li><li><p>默认桥接网络上的链接容器共享环境变量。</p><p>  本来，在两个容器之间共享环境变量的唯一方法是使用<code>--link</code>参数。用户自定义网络不支持这种共享环境变量的方法。然而，这里有更好的方法共享环境变量。一些思路：</p><ul><li>使用Docker volume，多个容器可以挂载包含共享信息的文件或者目录。</li><li>可以使用<code>docker-compose</code>启动多个容器，compose file可以定义共享变量。</li><li>你可以使用swarm services代替单一的容器，并利用其共享secret和configs的优点。</li></ul></li></ul><p>容器连接到同样的用户自定义桥接网络，可以有效的将所有端口相互开放。要使端口可以在不同网络上的容器或非Docker主机可以访问，必须使用<code>-p</code>或<code>--publish</code>参数发布该端口。</p><h2 id="管理用户自定义网桥"><a href="#管理用户自定义网桥" class="headerlink" title="管理用户自定义网桥"></a>管理用户自定义网桥</h2><p>使用<code>docker network create</code>命令创建用户自定义桥接网络。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create my-net</span><br></pre></td></tr></table></figure><p>你可以指定子网，IP地址范围，网关和其他参数。请参阅<a href="https://docs.docker.com/engine/reference/commandline/network_create/#specify-advanced-options" target="_blank" rel="noopener">docker network create</a>或者输出<code>docker network create --help</code>获取详细信息。</p><p>使用<code>docker network rm</code>命令删除用户自定义桥接网络。如果容器目前已连接此网络，请先断开它们。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network rm my-net</span><br></pre></td></tr></table></figure><blockquote><p><strong>实际会发生什么?</strong><br>当你创建或者删除一个用户自定义网桥，或者容器从一个用户自定义网桥连接或者断开连接，Docker使用特定工具管理操作系统的底层网络基础设施（比如在Linux上面增加、删除网桥设备或配置<code>iptables</code>规则）。这些细节应视为实施细节。让Docker为你管理用户自定义网桥。</p></blockquote><h2 id="将容器连接到用户自定义网桥"><a href="#将容器连接到用户自定义网桥" class="headerlink" title="将容器连接到用户自定义网桥"></a>将容器连接到用户自定义网桥</h2><p>当你创建一个新容器，你可以指定一个或者多个<code>--network</code>参数。这个例子将Nginx容器连接到<code>my-net</code>网络。还将容器中的80端口发布到Docker主机的8080端口上。所以外部客户端可以访问到该端口（容器的80端口）。连接到<code>my-net</code>网络的任何其他容器都可以访问<code>my-nginx</code>容器上的所有端口，反之亦然。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker create --name my-nginx \</span><br><span class="line">  --network my-net \</span><br><span class="line">  --publish 8080:80 \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><p>将一个运行中的容器连接到一个现有的用户自定义网桥，使用<code>docker network connect</code>命令。以下的命令将已经在运行的<code>my-nginx</code>容器连接到已经存在的<code>my-net</code>网络。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network connect my-net my-nginx</span><br></pre></td></tr></table></figure><h2 id="将容器与用户自定义网桥断开连接"><a href="#将容器与用户自定义网桥断开连接" class="headerlink" title="将容器与用户自定义网桥断开连接"></a>将容器与用户自定义网桥断开连接</h2><p>将正在运行的容器与用户自定义网桥断开连接，使用<code>docker network disconnect</code>命令。以下命令将<code>my-ngix</code>容器与<code>my-net</code>断开连接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network disconnect my-net my-nginx</span><br></pre></td></tr></table></figure><h2 id="使用IPv6"><a href="#使用IPv6" class="headerlink" title="使用IPv6"></a>使用IPv6</h2><p>如果你需要Docker容器对IPv6的支持，在创建IPv6网络或者分配IPv6地址之前，你需要在Docker守护进程上<a href="https://docs.docker.com/config/daemon/ipv6/" target="_blank" rel="noopener">启用该参数</a>，并重新加载其配置。</p><p>当你创建你的网络，你可以指定<code>--ipv6</code>参数开启IPv6。你不能在默认桥接网络上选择关闭IPv6的支持。</p><h2 id="开启从Docker容器转发到外界"><a href="#开启从Docker容器转发到外界" class="headerlink" title="开启从Docker容器转发到外界"></a>开启从Docker容器转发到外界</h2><p>默认情况下，由容器连接到默认桥接网络的流量不允许转发到外界。启用这流量转发，你需要改变两个设置。这些不是Docker命令，并且他们会影响Docker主机的内核。</p><ol><li><p>配置Linux内核以允许IP转发。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl net.ipv4.conf.all.forwarding=1</span><br></pre></td></tr></table></figure></li><li><p>改变<code>iptables</code> <code>FORWARD</code>策略由<code>DROP</code>为<code>ACCEPT</code>。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo iptables -P FORWARD ACCEPT</span><br></pre></td></tr></table></figure></li></ol><p>这些设置在重启后将会失效，所以你可能需要将它们添加到启动脚本中。</p><h2 id="使用默认桥接网络"><a href="#使用默认桥接网络" class="headerlink" title="使用默认桥接网络"></a>使用默认桥接网络</h2><p>默认<code>桥接</code>网络被认为是Docker的遗留功能，并且不推荐在生产环境中使用它。配置它需要手动操作，另外它有技术缺点。</p><h2 id="将容器连接到默认桥接网桥"><a href="#将容器连接到默认桥接网桥" class="headerlink" title="将容器连接到默认桥接网桥"></a>将容器连接到默认桥接网桥</h2><p>如果你不使用<code>--network</code>参数指定一个网络，并且指定了网络驱动程序，默认情况下，你的容器将连接到默认桥接网络。容器连接到默认桥接网络仅能通过IP地址进行通信，除非使用<a href="https://docs.docker.com/network/links/" target="_blank" rel="noopener">遗留的<code>--link</code>参数</a>链接它们。</p><h2 id="配置默认桥接网络"><a href="#配置默认桥接网络" class="headerlink" title="配置默认桥接网络"></a>配置默认桥接网络</h2><p>配置默认桥接网络，你需要在<code>daemon.json</code>中指定参数。这是一个有几个参数的<code>daemon.json</code>的例子。仅指定你需要自定义的配置。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"bip"</span>: <span class="string">"192.168.1.5/24"</span>,</span><br><span class="line">  <span class="attr">"fixed-cidr"</span>: <span class="string">"192.168.1.5/25"</span>,</span><br><span class="line">  <span class="attr">"fixed-cidr-v6"</span>: <span class="string">"2001:db8::/64"</span>,</span><br><span class="line">  <span class="attr">"mtu"</span>: <span class="number">1500</span>,</span><br><span class="line">  <span class="attr">"default-gateway"</span>: <span class="string">"10.20.1.1"</span>,</span><br><span class="line">  <span class="attr">"default-gateway-v6"</span>: <span class="string">"2001:db8:abcd::89"</span>,</span><br><span class="line">  <span class="attr">"dns"</span>: [<span class="string">"10.20.1.2"</span>,<span class="string">"10.20.1.3"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启Docker以使更改生效。</p><h2 id="在默认桥接网络使用IPv6"><a href="#在默认桥接网络使用IPv6" class="headerlink" title="在默认桥接网络使用IPv6"></a>在默认桥接网络使用IPv6</h2><p>如果配置Docker以支持IPv6（请参阅<a href="https://docs.docker.com/network/bridge/#use-ipv6" target="_blank" rel="noopener">使用IPv6</a>）,默认桥接网络已经自动配置IPv6。与用户自定义网桥不同，你不能在默认网桥选择关闭IPv6。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
            <tag> translation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[docker] networking overview</title>
      <link href="/2019-01/docker-networking-overview/"/>
      <url>/2019-01/docker-networking-overview/</url>
      
        <content type="html"><![CDATA[<blockquote><p>【翻译】相关声名：<a href="https://unihon.github.io/2019-01/statement-of-some-blog-articles/">https://unihon.github.io/2019-01/statement-of-some-blog-articles/</a></p></blockquote><a id="more"></a><blockquote><p>Docker v18.09<br>Configure networking<br>Overiew<br>原文链接：<a href="https://docs.docker.com/network/" target="_blank" rel="noopener">https://docs.docker.com/network/</a></p></blockquote><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>Docker容器和服务如此强大的原因之一是您可以将它们连接在一起,或者将它们连接到非Docker工作负载。Docker容器和服务甚至不需要知道它们是如何部署在Docker上，或者它们的对等端是否也是Docker工作负载。无论您的Docker主机是运行Linux，Windows还是两者兼而有之，您都可以使用Docker以与平台无关的方式管理它们。</p><p>本主题定义了一些基本的Docker网络概念，并为您准备设计和部署应用程序以充分利用这些功能。</p><p>大部分内容适用于所有Docker安装。但是，<a href="https://docs.docker.com/network/#docker-ee-networking-features" target="_blank" rel="noopener">一些高级功能</a>仅适用于Docker EE客户。</p><h2 id="本主题的范围"><a href="#本主题的范围" class="headerlink" title="本主题的范围"></a>本主题的范围</h2><p>本主题不涉及Docker网络如何在特定操作系统工作的详细信息，所以你找不到有关在Linux Docker如何操作<code>iptables</code>规则或者在Windows servers如何操作路由规则的信息，并且你将无法找到有关Docker如何形成并封闭数据包或者如何处理数据加密的详细信息。请参阅<a href="https://docs.docker.com/network/iptables/" target="_blank" rel="noopener">Docker和iptables</a>和<a href="http://success.docker.com/article/networking" target="_blank" rel="noopener">Docker参考架构：设计可扩展的便携式Docker容器网络</a>了解更具深度的技术细节。</p><p>另外，本主题不提供有关如何创建、管理和使用Docker网络的教程。每个章节都包含相关教程和命令参考的链接。</p><h2 id="网络驱动程序"><a href="#网络驱动程序" class="headerlink" title="网络驱动程序"></a>网络驱动程序</h2><p>使用驱动程序，Docker的网络子系统是可插拔的（灵活的）。默认情况下已经存有几个网络驱动，并提供核心网络功能：</p><ul><li><p><code>bridge</code>：默认的网络驱动程序。如果你不指定驱动程序，该类型的网络将会被创建。当您的应用程序在需要通信的独立容器中运行时，通常会使用桥接网络。请参阅<a href="https://docs.docker.com/network/bridge/" target="_blank" rel="noopener">桥接网络</a>。</p></li><li><p><code>host</code>：对于独立容器，删除容器和Docker主机之间的网络隔离，并直接使用主机的网络。<code>host</code>仅适用于在Docker 17.06及更高版本的swarm service。请参阅<a href="https://docs.docker.com/network/host/" target="_blank" rel="noopener">使用host网络</a>。</p></li><li><p><code>overlay</code>：Overlay网络将多个Docker守护进程连接起来，并使swarm services能够彼此通信。你还可以使用overlay网络促进swarm service和独立容器之间的通信，或者是在两个不同Docker守护进程的独立容器之间进行通信。这个策略消除了在这些容器之间执行OS级别路由的需要。请参阅<a href="https://docs.docker.com/network/overlay/" target="_blank" rel="noopener">overlay网络</a>。</p></li><li><p><code>macvlan</code>：Macvlan网络允许你给容器分配一个MAC地址，使其在你的网络上显示为物理设备。Docker守护进程通过他们的MAC地址将流量路由到容器。当处理期望直接连接到物理网络的遗留应用，使用<code>macvlan</code>网络是最好的选择，而不是通过Docker主机的网络堆栈进行路由。请参阅<a href="https://docs.docker.com/network/macvlan/" target="_blank" rel="noopener">Macvlan网络</a>。</p></li><li><p><code>none</code>：对于该容器，禁用所有的网络。通常与自定义网络驱动程序一起使用。<code>none</code>不适用于swarm services。请参阅<a href="https://docs.docker.com/network/none/" target="_blank" rel="noopener">禁用容器网络</a>。</p></li><li><p><code>Network plugins</code>：您可以使用Docker安装和使用第三方网络插件。可以从<a href="https://hub.docker.com/search?category=network&amp;q=&amp;type=plugin" target="_blank" rel="noopener">Docker Hub</a>或者是第三方供应商等到这些插件。有关安装和使用特定网络插件的信息，请参阅第三方的文件。</p></li></ul><h2 id="网络驱动程序小结"><a href="#网络驱动程序小结" class="headerlink" title="网络驱动程序小结"></a>网络驱动程序小结</h2><ul><li>当你需要多个容器在同一个Docker主机上进行通信时，<strong>用户自定义桥接网络</strong>是最好的选择。</li><li>当网络堆栈不与Docker主机隔离，但你希望隔离容器的其他方面，<strong>Host网络</strong>是最好的选择。</li><li>当你需要在不同Docker主机上运行的容器进行通信时，或者当多个应用程序使用swarm services一起工作时，<strong>Overlay网络</strong>是最好的选择。</li><li>当你从VM设置迁移或你需要容器都具有唯一的MAC地址，使其看起来像网络上的物理主机时，<strong>Macvlan网络</strong>是最好的选择。</li><li><strong>第三方的网络插件</strong>允许你将Docker和专门的网络堆栈集成。</li></ul><h2 id="Docker-EE网络功能"><a href="#Docker-EE网络功能" class="headerlink" title="Docker EE网络功能"></a>Docker EE网络功能</h2><p>以下两个功能仅支持Docker EE，并且使用Universal Control Plane (UCP)管理你的Docker服务。</p><ul><li><p><a href="https://docs.docker.com/datacenter/ucp/2.2/guides/admin/configure/use-domain-names-to-access-services/" target="_blank" rel="noopener">HTTP routing mesh</a>允许您在多个服务之间共享相同的网络IP地址和端口。根据客户端的请求，UCP使用主机名和端口的组合将流量路由到适当的服务。</p></li><li><p><a href="https://docs.docker.com/datacenter/ucp/2.2/guides/user/services/use-domain-names-to-access-services/#sticky-sessions" target="_blank" rel="noopener">Session stickiness</a>允许你在HTTP头中指定信息，UCP用于将后续请求路由到同一服务任务，适用于需要有状态会话的应用程序。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
            <tag> translation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>statement of some blog articles</title>
      <link href="/2019-01/statement-of-some-blog-articles/"/>
      <url>/2019-01/statement-of-some-blog-articles/</url>
      
        <content type="html"><![CDATA[<p>博客中的部分英文翻译，为个人学习中的一些“笔记”，并非专业翻译。</p><a id="more"></a><p>如你需查阅博客中的翻译文章，请同时参考文章的英文原文，以避免内容理解上的偏差。</p><p>因为个人的英文水平有限，同时也可能会使用各类的工具来协助自己对原文章的理解。翻译难免有不当的地方，如有疑问可向我发送相关的信息。</p>]]></content>
      
      
      <categories>
          
          <category> Mix </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> translation </tag>
            
            <tag> statement </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bash command search</title>
      <link href="/2019-01/bash-command-search/"/>
      <url>/2019-01/bash-command-search/</url>
      
        <content type="html"><![CDATA[<p>bash的历史命令搜索，个人常用的一个功能，其快捷键为C-R。C-R的功能是增量反向搜索，即根据输入的关键词从history中反向搜索，返回与关键词匹配的第一条命令（history中匹配的最后一条）。</p><a id="more"></a><p>如果停止输入然后继续按C-R，则返回与关键词匹配的第二条命令（history中匹配的倒数第二条），以此类推。</p><p>所谓增量，搜索返回匹配命令的history号码（offset偏移量）会在每次返回匹配命令时发生变化。比如在第一次使用C-R搜索到的命令，到第二次再用C-R搜索同样的关键词就不会再返回样的命令，原因是第二次的搜索结果是从第一次搜索到的命令的history的号码数（offset偏移量）基础上进行搜索。</p><p>然而，只能一个方向的搜索很不方便，实际上开发者并不是无脑就给这一个“反人类”的功能，其实还有一个增量正向的搜索，其快捷键为C-S。是不是很熟悉，这个快捷键我在刚开始用vim应该误按了不少，其功能是停止对标准输入的接收，即“冻屏”，这个按C-Q可以恢复。  </p><p>下面是bash手册的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reverse-search-history C-r)</span><br><span class="line">Search backward starting at( the current line and moving up&apos; through the history as necessary. This is an incremental search.</span><br><span class="line">forward-search-history C-s)</span><br><span class="line">Search forward starting at the current line and moving down&apos; through the history as  necessary. This is an incremental search.</span><br></pre></td></tr></table></figure><p>但为什么按C-S没有得到想要的增量搜索的功能，而是给“冻屏”了。其实我也看了一些网上的bash快捷键归纳，多数上是只说了C-R这一个增量反向搜索的快捷键，有的也提到了C-S，不过也没提到“冻屏”相关的信息。</p><p>之所以bash的C-S增量搜索功能没生效，是因为C-S这一输入在bash接收之前已经被TTY的程序监听到，接收并响应了————“冻屏”。</p><p>解决方法是修改、关闭TTY的“冻屏”功能的快捷键，如执行<code>stty stop &quot;&quot;</code>,其中TTY更多的设置信息可以执行<code>stty -a</code>输出。另外也可以执行<code>stty -ixon</code>解决。</p><p><img src="/2019-01/bash-command-search/20190119_bash_search.gif" alt>▲ bash历史命令搜索</p><p>除此还有M-R、M-S的非增量搜索命令，不过这两个命令只返回匹配关键词最近的第一条命令，而且不能预览匹配的命令。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bash </tag>
            
            <tag> stty </tag>
            
            <tag> hotkey </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>the problem of bootloader with uefi on virtualbox6</title>
      <link href="/2019-01/the-problem-of-bootloader-with-uefi-on-virtualbox6/"/>
      <url>/2019-01/the-problem-of-bootloader-with-uefi-on-virtualbox6/</url>
      
        <content type="html"><![CDATA[<p>本来在virtualbox5.2上面的通过UEFI引导的系统，在vb升级到6.0之后，出现的一个“诡异问题”。因为各种原因，我是直接将备份虚拟机的虚拟硬盘（VHD等）导入到vb6中，可能通过vb软件的直接升级不会有这个情况（具体没做测试）。</p><a id="more"></a><p>问题是这样的，在虚拟机系统开机的时候bootloader（grub等）的画面不显示，等待片刻后（应该是bootloader的等待时间到了）就直接进入系统了，也就是没有出现“引导菜单”的画面。其实在此之前恰逢我新建了一个虚拟机，就在给系统安装bootloader并调试的时候就“一头扎进这巨坑”了。明明该配的都已经配置好了，为什么还是没bootloader的画面。中间也用了一个debian的liveCD做测试，同样不能显示bootloader的画面。其中有个虚拟机是用传统BIOS启动的，然而那个就正常加载bootloader的画面。</p><p>在通过搜索各种网上资源都没解决后，我都开始怀疑这会不会是个bug…</p><p><img src="/2019-01/the-problem-of-bootloader-with-uefi-on-virtualbox6/20190116_bl_no.gif" alt>▲ 系统在开机后不显示bootloader画面直接进入系统</p><p>virtualbox 6.0默认的图形驱动是VMSVGA，如果是传统BIOS启动的话，这个模式是可以正常显示bootloader的画面的，不过如果是以UEFI启动的话，VMSVGA模式是不能显示bootloader的画面的！除了VMSVGA之外，还有VBoxVGA、VBoxSVGA。其中只有VBoxVGA模式才能在以UEFI方式启动的时候正常显示bootloader的画面。</p><p><img src="/2019-01/the-problem-of-bootloader-with-uefi-on-virtualbox6/20190116_vb_setting.png" alt>▲ 虚拟机的显示模式设置</p><p><img src="/2019-01/the-problem-of-bootloader-with-uefi-on-virtualbox6/20190116_bl_yes.gif" alt>▲ 设置为VBoxVGA模式后系统开机正常显示bootloader画面</p><p>后面在6.0.4的更新日志中可以看到，有一条“EFI增加VMSVGA图形驱动的支持”的条目，可见在6.0.4之前，VMSVGA是不支持EFI的，这也就解释了为什么前面的6.0在使用UEFI启动系统时不显示“引导菜单”的画面。后面经测试在virtualbox 6.0.4版本，在使用UEFI启动系统并使用默认的图形驱动，也就是VMSVGA，确实可以显示“引导菜单”的画面，不过另一个图形驱动VBoxSVGA目前还是没有支持EFI。</p><blockquote><p>Version 6.0.4 (2019-01-28)<br>This is a maintenance release. The following items were fixed and/or added:<br>Virtualization core: support Shanghai/Zhaoxin CPUs.  </p><ul><li>User interface: handle command line arguments to VirtualBox correctly (bugs #18206 and #18197)</li><li>User interface: improvements to machine manager window, virtual optical disk creator, storage selector window and log viewer window</li><li>User interface: various small fixes and improvements</li><li>Audio: implemented time scheduling for the AC’97 device emulation to keep audio and video in sync</li><li><strong>Graphics: basic support for VMSVGA graphics device in virtual machines using EFI</strong></li><li>Network: fix occasional NATNet crashes (bug #13899)</li><li>Network: worked around problems in certain PCnet drivers on old operating systems</li><li>Serial: fixed connecting to pseudo terminals on POSIX hosts (6.0.0 regression; bug #18319)</li><li>Linux hosts and guests: fix for building kernel modules against Linux 5.0. Thank you Kyle Laker</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VirtualBox </tag>
            
            <tag> bootloader </tag>
            
            <tag> grub2 </tag>
            
            <tag> uefi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>boot loader grub</title>
      <link href="/2019-01/boot-loader-grub/"/>
      <url>/2019-01/boot-loader-grub/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注：文章例子配置环境为UEFI-GPT</p></blockquote><h1 id="boot-loader基本功能"><a href="#boot-loader基本功能" class="headerlink" title="boot loader基本功能"></a>boot loader基本功能</h1><ul><li>提供选单：用户可以选择不同的开机项目，这也是多重引导的重要功能；</li><li>载入核心文件：直接指向可开机的程序区段来开始操作系统；</li><li>转交其他 loader：将开机管理功能转交给其他 loader 负责。</li></ul><h1 id="grub2"><a href="#grub2" class="headerlink" title="grub2"></a>grub2</h1><p>适用于BIOS和UEFI的启动加载器（boot loaders）。<br>grub2支持两种方式引导操作系统</p><ul><li>直接引导：(direct-load)直接通过默认的grub2 boot loader来引导写在默认配置文件中的操作系统</li><li>链式引导：(chain-load)使用默认grub2 boot loader链式引导另一个boot loader，该boot loader将引导对应的操作系统</li></ul><p>一般只使用第一种方式，只有想引导grub默认不支持的操作系统时才会使用第二种方式。</p><h1 id="设置引导"><a href="#设置引导" class="headerlink" title="设置引导"></a>设置引导</h1><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>配置文件和grub命令行基本一样</p><ol><li><p>set root=(hd0,1)<br>(hd0,1)为boot的硬盘和分区，这个一定要对，grub2的硬盘从0开始算，分区从1开始算，注意的是，硬盘的顺序可能会改变，如在主机添加或移去一个硬盘（设备）的时候。</p></li><li><p>linux /vmlinuz-linux root=/dev/sda2 rw quiet<br>vmlinuz-linux为内核文件，vm代表虚拟内存，z代表压缩过。<br>这里的root指的是内核的linux的根目录的硬盘-分区，也就是平时的linux的根目录的硬盘-分区，可以用/dev/sda2表示，也可以用root=UUID=xxx（该分区的UUID）表示。这个root必须指明，不然会在系统启动时出错，如提示先加载内核什么的。</p><p> linux命令除了root还有其他的一些“内核参数”</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">init=：指定Linux启动的第一个进程init的替代程序。</span><br><span class="line">root=：指定根文件系统所在分区，在grub中，该选项必须给定。</span><br><span class="line">ro,rw：启动时，根分区以只读还是可读写方式挂载。不指定时默认为ro。</span><br><span class="line">initrd：指定init ramdisk的路径。在grub中因为使用了initrd或initrd16命令，所以不需要指定该启动参数。</span><br><span class="line">rhgb：以图形界面方式启动系统。</span><br><span class="line">quiet：以文本方式启动系统，且禁止输出大多数的<span class="built_in">log</span> message。</span><br><span class="line">net.ifnames=0：用于CentOS 7，禁止网络设备使用一致性命名方式。</span><br><span class="line">biosdevname=0：用于CentOS 7，也是禁止网络设备采用一致性命名方式。</span><br><span class="line">只有net.ifnames和biosdevname同时设置为0时，才能完全禁止一致性命名，得到eth0-N的设备名。</span><br></pre></td></tr></table></figure></li><li><p>Initrd /initramfs-linux.img<br>这个文件用来加载各种模块</p></li><li><p>boot<br>因为配置文件在末尾会隐性加上boot，所以配置文件可以不写。</p></li></ol><h2 id="root变量"><a href="#root变量" class="headerlink" title="root变量"></a>root变量</h2><p>一般root变量表示/boot所在的分区，但这不是绝对的，如果设置为根文件系统所在分区，如root=(hd0,gpt2)，则后续可以使用/etc/fstab来引用”(hd0,gpt2)/etc/fstab”文件。假设boot所在的硬盘-分区为(hd0,1)</p><ul><li>如果boot不是一个独立的分区/boot/file–&gt;(/)/boot/file–&gt;(hd0,1)/boot/filegrub里面访问文件的路径为(hd0,1)/boot/file</li><li>如果boot是一个独立的分区/boot/file–&gt;(/boot)/file–&gt;(hd0,1)/file因为boot分区为grub的根目录，所以(hd0,1)表示的是就是boot/，所以在grub里面路径的形式为(hd0,1)/file而不是(hd0,1)/boot/file</li></ul><p>在定义了root变量之后，后续就可以直接用/dir/file的形式表示(hd0,1)/dir/file。其中grub里面绝对路径的形式为(hd0,1)/dir/file，相对路径的形式为/dir/file，这个linux里的定义有点区别。</p><h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p>列出文件（夹）、设备  </p><h2 id="Chainloader"><a href="#Chainloader" class="headerlink" title="Chainloader"></a>Chainloader</h2><p>链加载，加载当前分区启动或者从文件启动，可直接启动efi文件。ChainLoading的意思是用当前的bootloader去载入另一个bootloader,所以叫做链式加载.这个bootloader可能位于MBR,也可能在另一个分区的引导扇区上。</p><ol><li>chainloader +1<br>此处’+1’是指示GRUB读入分区的第一个扇区的引导记录。<br>这个可能会提示说”找不到EFI的路径“，不知道为什么这里的EFI“变小写了“（大写的文件（夹）名全变小写），在设置root变量后，(/boot/efi)/EFI/xx，原本应该这样访问–&gt;/EFI/xx，但正确的访问方式是–&gt;/efi/xx或者(hd1,1)/efi/xx。</li></ol><p><img id="sm" src="/2019-01/boot-loader-grub/20190113_esp.png">▲ ESP信息</p><p><img id="sm" src="/2019-01/boot-loader-grub/20190113_grub.png">▲ grub shell下ESP里面的文件路径情况</p><p>初步判定和fat32的长文件名、短文件名或mount sortename的参数有关。如果是通过mount挂载的话，可以设置sortename，不过grub那里的设备挂载目前没能找到与之相关的设置。</p><ol start="2"><li>chainloader (hd1,1)/efi/grub/boot.efi<br>直接从文件启动，如果指定root变量可以用相对路径</li></ol><h2 id="lsmod"><a href="#lsmod" class="headerlink" title="lsmod"></a>lsmod</h2><p>列出所有模块</p><h2 id="insmod"><a href="#insmod" class="headerlink" title="insmod"></a>insmod</h2><p>加载某个模块</p><h2 id="prefix变量"><a href="#prefix变量" class="headerlink" title="prefix变量"></a>prefix变量</h2><p>设置grub模块和配置文件的路径</p><h2 id="probe"><a href="#probe" class="headerlink" title="probe"></a>probe</h2><p>探测分区或磁盘的属性信息。如果未指定–set，则显示指定设备对应的信息。如果指定了–set，则将对应信息的值赋给变量var。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">probe [--<span class="built_in">set</span> var] --partmap|--fs|--fs-uuid|--label device </span><br><span class="line">--partmap：显示是gpt还是mbr格式的磁盘。</span><br><span class="line">--fs：显示分区的文件系统。</span><br><span class="line">--fs-uuid：显示分区的uuid值。</span><br><span class="line">--label：显示分区的label值。</span><br></pre></td></tr></table></figure><h1 id="os-prober自动扫描系统添加引导"><a href="#os-prober自动扫描系统添加引导" class="headerlink" title="os-prober自动扫描系统添加引导"></a>os-prober自动扫描系统添加引导</h1><p>安装os-prober后，可以将安装了其他系统的硬盘（分区）挂载，然后再重新生成grub.cfg文件，他会自动扫描并添加引导条目到启动菜单，其中有两种情况。</p><ol><li>如果挂载的是其他系统的/boot分区（目录），那么扫描到是将是这个系统的bootloader，菜单添加的内容是“转交bootloader控制权”的条目，这样的引导形式为链式引导</li><li>如果挂载的是其他系统的/根分区（目录），那么扫描到是将是这个系统的核心，菜单添加的内容是“加载这个系统核心”的条目，这样的引导形式为直接引导</li></ol><p>个人建议将整个系统进行挂载，然后扫描。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://wiki.archlinux.org/index.php/Installation_guide" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Installation_guide </a></li><li><a href="https://wiki.archlinux.org/index.php/EFI_system_partition" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/EFI_system_partition </a></li><li>鸟哥的Linux私房菜-基础篇（第四版）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bootloader </tag>
            
            <tag> grub2 </tag>
            
            <tag> uefi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>update the function of toc for management</title>
      <link href="/2019-01/update-the-function-of-toc-for-management/"/>
      <url>/2019-01/update-the-function-of-toc-for-management/</url>
      
        <content type="html"><![CDATA[<p>因为management主题原有的目录功能有点“鸡肋”，所以花了点时间对其进行升级。</p><ul><li><a href="https://unihon.github.io/2018-12/knowledge-induction-of-disk-management/">效果链接</a></li></ul><a id="more"></a><p><img src="/2019-01/update-the-function-of-toc-for-management/20190113_ori_pc.png" alt>▲ 原大屏端目录</p><p><img src="/2019-01/update-the-function-of-toc-for-management/20190113_new_pc.png" alt>▲ 更新后大屏端目录</p><p><img id="sm" src="/2019-01/update-the-function-of-toc-for-management/20190113_ori_m.jpg">▲ 原小屏端目录</p><p><img id="sm" src="/2019-01/update-the-function-of-toc-for-management/20190113_new_m.jpg">▲ 更新后小屏端目录</p><hr><p>js可以利用css的变量间接的控制像before、after这样的伪类。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//css</span><br><span class="line"></span><br><span class="line"><span class="selector-pseudo">:root</span>&#123;</span><br><span class="line"><span class="attribute">--my-css-var</span>: <span class="string">'abc'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line"><span class="attribute">content</span>: <span class="built_in">var</span>(--my-css-var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//js</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">':root'</span>).css(<span class="string">'--my-css-var'</span>,<span class="string">'new var'</span>);</span><br></pre></td></tr></table></figure><p>另外标签属性（样式，下同）在通过js重新设置后需要记录话，也可以借助css变量。<br>比如有个标签T。</p><ol><li>首先在大屏端js改变T的属性（A）</li><li>然后切换到小屏端，小屏端js也同样更新了T的属性（a）</li><li>下次在小屏端切换回大屏端的时候A已经被a所覆盖</li></ol><p>如果通过css变量保存A，再配合css的媒体查询，这样就可以在上面第3步小屏切换回大屏的时候，经过媒体查询从变量中取出A重新设置T的属性进行还原，小屏端也同理。这样无论两边怎么修改，都不会影响彼此。</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>easy to cp files from windows to wsl</title>
      <link href="/2019-01/easy-to-cp-files-from-windows-to-wsl/"/>
      <url>/2019-01/easy-to-cp-files-from-windows-to-wsl/</url>
      
        <content type="html"><![CDATA[<p>一个方便从windows复制文件或者目录到wsl的一个shell脚本。</p><a id="more"></a><p><img src="/2019-01/easy-to-cp-files-from-windows-to-wsl/20190102_demo.gif" alt>▲ 效果</p><p>源码如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">str=<span class="variable">$1</span></span><br><span class="line"></span><br><span class="line">tmp=<span class="variable">$&#123;str//\\/\/&#125;</span></span><br><span class="line">row=<span class="variable">$&#123;tmp//\ /\\ &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">typeset</span> -l partition=$(<span class="built_in">echo</span> <span class="variable">$row</span>|cut -d <span class="string">":"</span> -f1)</span><br><span class="line">uri=$(<span class="built_in">echo</span> <span class="variable">$row</span>|cut -d <span class="string">":"</span> -f2)</span><br><span class="line">uri_l=<span class="string">"/mnt/"</span><span class="variable">$&#123;partition&#125;</span><span class="variable">$&#123;uri&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$uri_l</span>|xargs -i cp -r &#123;&#125; .</span><br></pre></td></tr></table></figure><p>字符串要替换第一个匹配的目标，写法为<code>${str/old/new}</code>，若要全部替换则为<code>${str//old/new}</code>。</p><p>主要要记下<code>xrags的用法</code>，下面是man xrags的解释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-I replace-str</span><br><span class="line">              Replace occurrences of replace-str in the initial-arguments with names read from standard input.  Also,</span><br><span class="line">              unquoted  blanks do not terminate input items; instead the separator is the newline character.  Implies</span><br><span class="line">              -x and -L 1.</span><br><span class="line"></span><br><span class="line">-i[replace-str], --replace[=replace-str]</span><br><span class="line">              This option is a synonym for -Ireplace-str if replace-str is specified.  If the replace-str argument is</span><br><span class="line">              missing, the effect is the same as -I&#123;&#125;.  This option is deprecated; use -I instead.</span><br></pre></td></tr></table></figure><p><code>-I</code>和<code>i</code>大体上的意思是将xrags导过来的数据用<code>{}</code>取代</p><p>另外<code>cut</code>用<code>-d</code>选项指定分隔符，默认为制表符（TAB）。</p><hr><ul><li><a href="https://github.com/unihon/shell/tree/master/wcp" target="_blank" rel="noopener">脚本链接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WSL </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Extend space for LVM on virtualbox</title>
      <link href="/2018-12/extend-space-for-lvm/"/>
      <url>/2018-12/extend-space-for-lvm/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://unihon.github.io/2018-12/knowledge-induction-of-disk-management/">Knowledge induction of hard management</a></li></ul><p><img src="/2018-12/extend-space-for-lvm/20181204_befor.png" alt>▲ 原来的硬盘大小</p><p>虚拟机里要对LVM的进行扩容，在原来虚拟机硬盘空间不足的时候进行容量扩展。如是动态的虚拟硬盘，可以在后期对空间进行扩展，不过注意的是，动态虚拟硬盘的空间只能扩展，不能对其空间进行收缩。也可以重新创建一个虚拟硬盘，然后扩充到虚拟机上面。这里主要讲下对动态虚拟硬盘的空间进行扩展。</p><p><img src="/2018-12/extend-space-for-lvm/20181204_modify.png" alt>▲ 对原来的动态vhd进行容量扩展</p><p><img src="/2018-12/extend-space-for-lvm/20181204_after.png" alt>▲ 动态虚拟硬盘空间扩展后</p><p><asciinema-player src="/2018-12/extend-space-for-lvm/20181204_disk.cast" poster="npt:0:5"></asciinema-player>▲ 对LVM扩容</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lvm </tag>
            
            <tag> VirtualBox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Knowledge induction of hard management</title>
      <link href="/2018-12/knowledge-induction-of-disk-management/"/>
      <url>/2018-12/knowledge-induction-of-disk-management/</url>
      
        <content type="html"><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><ul><li>MBR最多只能分4个主分区，可以用一个扩展分区代替一个主分区，扩展分区可以分出多个逻辑分区</li><li>GPT全是主分区，没扩展分区说法</li><li>分区要格式化（分配对应的文件系统xfs、extn）后才能使用</li><li>cat /proc/partitions，查看系统支持的文件系统</li><li>/etc/mtab，实时挂载文件（mount命令），只读</li><li>/etc/fstab，开机挂载文件</li></ul><a id="more"></a><h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><ul><li><p>lsblk</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">选项与参数：</span><br><span class="line"></span><br><span class="line">-d ：仅列出磁盘本身，并不会列出该磁盘的分区数据 </span><br><span class="line">-f ：同时列出该磁盘内的文件系统名称 </span><br><span class="line">-i ：使用 ASCII 的线段输出，不要使用复杂的编码 (再某些环境下很有用)</span><br><span class="line">-m ：同时输出该装置在 /dev 底下的权限数据 (rwx 的数据) </span><br><span class="line">-p ：列出该装置的完整文件名！而不是仅列出最后的名字而已。 </span><br><span class="line">-t ：列出该磁盘装置的详细数据，包括磁盘队列机制、预读写的数据量大小等</span><br><span class="line"></span><br><span class="line">仅列出 /dev/vda 装置内的所有数据的完整文件名</span><br><span class="line">lsblk -ip /dev/vda</span><br></pre></td></tr></table></figure></li><li><p>blkid找出装置的UUID</p></li><li>parted列出磁盘的分区表类型与分区信息<br>parted /dev/vda print</li></ul><h2 id="磁盘分区工具"><a href="#磁盘分区工具" class="headerlink" title="磁盘分区工具"></a>磁盘分区工具</h2><ul><li>MBR（msdos） 分区表请使用 fdisk 分区</li><li>GPT 分区表请 使用 gdisk 分区</li><li>parted用于GPT分区表</li><li>partprobe<br>利用这个可以不重启就可以更新Linux核心的分区表信息，<code>partprobe -s</code>输出信息</li></ul><h2 id="mkfs-tag：格式化分区"><a href="#mkfs-tag：格式化分区" class="headerlink" title="mkfs.tag：格式化分区"></a>mkfs.tag：格式化分区</h2><ul><li>tag为相应的文件系统，如xfs</li><li>如果在删除一个已经格式化过的分区，并接着新创建一个分区，那么这个分区可能还保留着之前分区的文件系统，可以加入-f选项覆盖</li></ul><h2 id="创建分区基本步骤"><a href="#创建分区基本步骤" class="headerlink" title="创建分区基本步骤"></a>创建分区基本步骤</h2><ol><li>透过lsblk或blkid先找到磁盘</li><li>用parted /dev/xxx print或者fdisk、gdisk等工具来找出内部的分区表类型</li><li>之后再用gdisk、fdisk等分区工具来操作</li><li>最后用mkfs格式化分区（有时可选，如扩展分区的时候）</li></ol><h1 id="LVM"><a href="#LVM" class="headerlink" title="LVM"></a>LVM</h1><p>LVM是Linux环境中对磁盘分区进行管理的一种机制，是建立在硬盘和分区之上、文件系统之下的一个逻辑层，可提高磁盘分区管理的灵活性。RHEL5默认安装的分区格式就是LVM逻辑卷的格式，需要注意的是/boot分区不能基于LVM创建，必须独立出来。</p><p><img src="/2018-12/knowledge-induction-of-disk-management/20181203_lvm.png" alt>▲ LVM组成图</p><p>LVM的灵活性很高，LV容量不够的时候，可以不对该LV的分区的容量重新次分配，可以在硬盘上新增加一个分区，利用这个新分区创建PV，将新建的PV扩展到要扩展容量的LV同一个VG，这样这个VG的PE数量就增加了，最后就可以利用这些PE给LV扩展容量。整个过程对LV原有的数据是无损的。</p><p><img src="/2018-12/knowledge-induction-of-disk-management/20181203_relation.png" alt>▲ LVM相关元素</p><p><img src="/2018-12/knowledge-induction-of-disk-management/20181203_command.png" alt>▲ LVM相关操作命令</p><h2 id="创建LVM基本步骤"><a href="#创建LVM基本步骤" class="headerlink" title="创建LVM基本步骤"></a>创建LVM基本步骤</h2><ol><li>硬盘分区</li><li>利用硬盘分区创建PV</li><li>利用PV创建（归入）VG</li><li>创建LV（来自同一个VG的PE才能生成LV）</li><li>格式化LV分区</li><li>MOUNT分区</li></ol><h1 id="重新分配分区"><a href="#重新分配分区" class="headerlink" title="重新分配分区"></a>重新分配分区</h1><p>主要有两种情况，一种是不用LVM的传统分区，另一个则是用LVM的分区。<br>主要以扩容为主，缩容为扩容的的逆过程。</p><h2 id="传统分区的重分配"><a href="#传统分区的重分配" class="headerlink" title="传统分区的重分配"></a>传统分区的重分配</h2><p>传统的分区（不用LVM），对一个分区的容量重新分配往往是比较麻烦的，而且限制很多。想对一个分区在保留原数据的情况下重新分配，就得删除该分区并重新创建一个分区，新分配的分区的开始磁柱号码必须和原分区的磁柱号码一致。这就意味这只有在硬盘最后面的一个分区能够进行保留原数据的重新分配，如果是一个在中间的分区，就必定会影响到该中间分区后面的分区（如果重新分配的大小比原来大小，原理上说不会影响到后面的分区）。</p><h3 id="相关命令-1"><a href="#相关命令-1" class="headerlink" title="相关命令"></a>相关命令</h3><ul><li><p>e2fscke2fsck是检查ext2、ext3、ext4等文件系统的正确性。<br>-f : 强制检查</p></li><li><p>resize2fs<br>resize2fs - ext2/ext3/ext4文件系统重定义大小工具。<br>resize2fs /dev/sda2 （设备点）<br>-f：强制执行调整大小操作，覆盖掉安全检查操作<br>-p：打印已完成的百分比进度条</p></li><li><p>xfs_growfs<br>xfs_growfs - xfs_growfs文件系统重定义大小工具。<br>xfs_growfs / （文件系统挂载点）<br>如果采用LVM，也可以是LVM的设备点，如xfs_growfs /dev/vg/lv。<br>注意普通分区不能用设备点，如xfs_growfs /dev/sda2。</p></li></ul><blockquote><p>xfs文件系统，只能对分区进行扩容，不能缩容</p></blockquote><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>使用分区管理工具（fdisk、gdisk等）删除要重新分配的分区  </li><li>紧接着新创建一个为目标容量的分区，确保新的分区开始的磁柱号码和原分区的开始磁柱号码一样  </li><li>使用partprobe更新Linux核心的分区表信息  </li><li>调整后的分区不需要重新格式化  </li><li>extn文件系统<br>5.1 使用e2fsck对调整后的分区进行检查<br>5.2 使用resize2fs对文件系统重定义大小  </li><li>xfs文件系统<br>6.1 使用xfs_growfs对文件系统重定义大小  </li></ol><h2 id="LVM分区的重分配"><a href="#LVM分区的重分配" class="headerlink" title="LVM分区的重分配"></a>LVM分区的重分配</h2><p>对LVM重分配，最终目的就是改变LV容量，LV的容量由VG的PE数量决定（下面主要是扩容）</p><h3 id="LVM分区重分配的几种方法"><a href="#LVM分区重分配的几种方法" class="headerlink" title="LVM分区重分配的几种方法"></a>LVM分区重分配的几种方法</h3><ul><li>如果LV对应VG还有PE剩余可用，可以直接利用这部分PE对LV进行扩容<ol><li>lvextend、lvresize分配LV容量</li><li>用resize2fs、xfs_growf调整LV数据</li></ol></li><li>另外再创建一个新的分区，利用该分区创建PV并扩展到对应的VG，将新的PE对LV进行扩容<ol><li>pvcreate /dev/sda2</li><li>vgextend 目标VG /dev/sda2</li><li>lvextend、lvresize分配LV容量</li><li>用resize2fs、xfs_growf调整LV数据</li></ol></li><li>直接将LV对应的VG上面的PV进行扩容，也就是对已经在使用的分区进行扩容（和普通分区扩容一样,局限性和也普通分区扩容一样，不推荐）<ol><li>删除原分区，接着新创建一个分区，之后不用格式化</li><li>pvresize /dev/sda2 重新分配PV大小</li><li>lvextend、lvresize分配LV容量</li><li>用resize2fs、xfs_growf调整LV数据</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> partition </tag>
            
            <tag> lvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>add asciinema player to the hexo(maupassant theme)</title>
      <link href="/2018-12/add-asciinema-player-to-the-hexo/"/>
      <url>/2018-12/add-asciinema-player-to-the-hexo/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://asciinema.org/" target="_blank" rel="noopener">asciinema player 官网</a></li><li><a href="https://asciinema.org/docs/how-it-works" target="_blank" rel="noopener">asciinema player 文档</a></li><li><a href="https://github.com/asciinema/asciinema-player" target="_blank" rel="noopener">asciinema player Github</a></li><li><a href="https://github.com/asciinema/asciinema-player/releases" target="_blank" rel="noopener">asciinema player web 播放器</a></li></ul><p>在主机安装好asciinema就可以直接用，因为是保存本地，所有没必要去注册一个账号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asciinema rec filename.cast</span><br></pre></td></tr></table></figure><p>这样就可以将录屏直接保存到本地，文件后缀可以是cast、json，注意的是hexo用json格式有问题（也可能是maupassant主题的原因）</p><p><strong> 下面将asciinema加到hexo，这里用的是maupassant主题，其他主题大同小异 </strong></p><p><a href="https://hexo.io/zh-cn/docs/themes" target="_blank" rel="noopener">hexo 主题的内容</a></p><p><img id="sm" src="/2018-12/add-asciinema-player-to-the-hexo/20121202_tree.png">▲ maupassant主题结构</p><p><code>themes/maupassant/sources/</code>文件夹里面就是静态文件的内容，将下载好的asciinema player播放器的js和css文件放到这里面</p><p>分析可以知道maupassant主题的<code>页面模板的头</code>是<code>layout/_partial/head.pug</code>，对应的引入js的页面模板是<code>layout/_partial/footer.pug</code></p><p><img src="/2018-12/add-asciinema-player-to-the-hexo/20121202_code.png" alt>▲ 在模板头、尾分别引入播放器的css和js</p><p>这里我加了一个是否启用asciinema player播放器的开关<code>if page.asciinema == true</code>（<a href="https://hexo.io/zh-cn/docs/variables" target="_blank" rel="noopener">hexo 变量的内容</a>），因为一般不会有非常多的文章都用到这个播放器，如果每个页面、文章都加载就有点多余了。<br>MD头如下，在asciinema为true时就启用播放器。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">layout: post</span><br><span class="line">title: add asciinema player to the hexo(maupassant theme) </span><br><span class="line">categories:</span><br><span class="line"><span class="bullet">- </span>Web</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">- </span>asciinema</span><br><span class="line"><span class="bullet">- </span>Hexo</span><br><span class="line">asciinema: true</span><br><span class="line">date: 2018-12-02 20:24:41</span><br><span class="line">updated: 2018-12-02 20:24:41</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>这样，全部工作就完成了，在md里插入播放器就直接用官网的方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">asciinema-player</span> <span class="attr">src</span>=<span class="string">"/xxx/file.cast"</span>&gt;</span><span class="tag">&lt;/<span class="name">asciinema-player</span>&gt;</span></span><br></pre></td></tr></table></figure><p><asciinema-player src="/2018-12/add-asciinema-player-to-the-hexo/first.cast" poster="npt:0:5"></asciinema-player>▲ 成品</p><p>其实有点悲伤，开始想给自己的hexo加入asciinema，就直接动手改现在的主题了，在我弄完之后，才回想起hexo插件这回事，然后马上上去查了下，还真有，心凉~</p><p><img src="/2018-12/add-asciinema-player-to-the-hexo/20121202_hexo.png" alt>▲ hexo官网上的asciinema插件</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> asciinema </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>graphic of vim and tmux</title>
      <link href="/2018-11/vim-tmux-graphic/"/>
      <url>/2018-11/vim-tmux-graphic/</url>
      
        <content type="html"><![CDATA[<p>vim 和 tmux 中的元素关系图。</p><a id="more"></a><img src="/2018-11/vim-tmux-graphic/20190607_buffer_window_tab.jpg"><p>▲ vim：buffer-window-tab</p><img src="/2018-11/vim-tmux-graphic/20190607_session_window_pane.jpg"><p>▲ tmux：session-window-pane</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
            <tag> tmux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>personal-vimrc</title>
      <link href="/2018-11/personal-vimrc/"/>
      <url>/2018-11/personal-vimrc/</url>
      
        <content type="html"><![CDATA[<p>Personal vimrc</p><a id="more"></a><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> encoding=utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">colorscheme</span> elflord</span><br><span class="line"><span class="keyword">syntax</span> enable</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">number</span></span><br><span class="line"><span class="keyword">set</span> numberwidth=<span class="number">2</span></span><br><span class="line"><span class="keyword">highlight</span> CursorLineNr ctermfg=<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> cursorline</span><br><span class="line"><span class="keyword">set</span> hlsearch</span><br><span class="line"><span class="keyword">set</span> cmdheight=<span class="number">1</span></span><br><span class="line"><span class="keyword">set</span> wildmenu</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> tabstop=<span class="number">4</span></span><br><span class="line"><span class="keyword">set</span> softtabstop=<span class="number">4</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span>=<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> backspace=<span class="number">2</span></span><br><span class="line"><span class="keyword">set</span> updatetime=<span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" tab map key</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;F5&gt;</span> :<span class="keyword">tabfirst</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;F6&gt;</span> :<span class="keyword">tablast</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;F7&gt;</span> :<span class="keyword">tabprevious</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;F8&gt;</span> :<span class="keyword">tabnext</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" windows size control map key</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;F9&gt;</span> :<span class="keyword">vertical</span> <span class="keyword">resize</span> +<span class="number">2</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;F10&gt;</span> :<span class="keyword">vertical</span> <span class="keyword">resize</span> -<span class="number">2</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;F11&gt;</span> :<span class="keyword">resize</span> +<span class="number">2</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;F12&gt;</span> :<span class="keyword">resize</span> -<span class="number">2</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">z</span> gg=G<span class="symbol">&lt;C-o&gt;</span><span class="symbol">&lt;C-o&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">j</span> :%!python -<span class="keyword">m</span> json.tool</span><br><span class="line"></span><br><span class="line"><span class="comment">" StatusLine and TabLine</span></span><br><span class="line"><span class="comment">" ------------------------------------------------</span></span><br><span class="line"><span class="comment">" StatusLine</span></span><br><span class="line"><span class="keyword">set</span> laststatus=<span class="number">2</span></span><br><span class="line"><span class="keyword">set</span> statusline=%<span class="keyword">f</span>\ %#CgMf#%<span class="keyword">m</span>%*%=%<span class="keyword">y</span>\ %&#123;&amp;fileencoding!=<span class="string">''</span>?<span class="string">'['</span>.&amp;fileencoding.<span class="string">']'</span>:<span class="string">''</span>&#125;\ %&#123;<span class="string">'['</span>.&amp;fileformat.<span class="string">']'</span>&#125;\ %<span class="number">10</span>(%<span class="keyword">l</span>,%<span class="keyword">c</span>%)\ =%L\ %<span class="keyword">P</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" TabLine</span></span><br><span class="line"><span class="keyword">set</span> showtabline=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyTabLine</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">let</span> s = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">tabpagenr</span>(<span class="string">'$'</span>))</span><br><span class="line"><span class="keyword">if</span> i + <span class="number">1</span> == <span class="built_in">tabpagenr</span>()</span><br><span class="line"><span class="keyword">let</span> s .= <span class="string">'%#TabLineSel#'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">let</span> s .= <span class="string">'%#TabLine#'</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s .= <span class="string">' ('</span> . <span class="built_in">tabpagewinnr</span>((i + <span class="number">1</span>),<span class="string">'$'</span>) . <span class="string">')'</span></span><br><span class="line"><span class="keyword">let</span> s .= <span class="string">' %&#123;MyTabLabel('</span> . (i + <span class="number">1</span>) . <span class="string">')&#125; '</span></span><br><span class="line"><span class="keyword">endfor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s .= <span class="string">'%#TabLineFill#'</span></span><br><span class="line"><span class="keyword">let</span> s .= <span class="string">"%=[%&#123;tabpagenr()&#125;/%&#123;tabpagenr('$')&#125;]"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyTabLabel</span><span class="params">(n)</span></span></span><br><span class="line"><span class="keyword">let</span> buflist = <span class="built_in">tabpagebuflist</span>(<span class="variable">a:n</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="built_in">winnr</span> = <span class="built_in">tabpagewinnr</span>(<span class="variable">a:n</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pathshorten</span>(<span class="built_in">bufname</span>(buflist[<span class="built_in">winnr</span> - <span class="number">1</span>]))</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> tabline=%!MyTabLine()</span><br><span class="line"></span><br><span class="line"><span class="comment">" StatusLine and TabLine highlight</span></span><br><span class="line"><span class="keyword">if</span> &amp;t_Co &gt; <span class="number">8</span> </span><br><span class="line"><span class="comment">" 16 or 256 color</span></span><br><span class="line"><span class="comment">"</span></span><br><span class="line"><span class="comment">" StatusLine</span></span><br><span class="line"><span class="keyword">highlight</span> StatusLine cterm=bold ctermfg=<span class="number">0</span> ctermbg=<span class="number">10</span></span><br><span class="line"><span class="keyword">highlight</span> StatusLineNc cterm=NONE ctermfg=<span class="number">0</span> ctermbg=<span class="number">7</span></span><br><span class="line"><span class="keyword">highlight</span> CgMf cterm=bold ctermfg=<span class="number">0</span> ctermbg=<span class="number">11</span></span><br><span class="line"><span class="comment">" TabLine</span></span><br><span class="line"><span class="keyword">highlight</span> TabLineSel cterm=bold ctermfg=<span class="number">0</span> ctermbg=<span class="number">10</span></span><br><span class="line"><span class="keyword">highlight</span> TabLine cterm=NONE ctermfg=<span class="number">7</span> ctermbg=<span class="number">8</span></span><br><span class="line"><span class="keyword">highlight</span> TabLineFill cterm=bold ctermfg=<span class="number">0</span> ctermbg=<span class="number">7</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">" 8 color</span></span><br><span class="line"><span class="comment">"</span></span><br><span class="line"><span class="comment">" StatusLine</span></span><br><span class="line"><span class="keyword">highlight</span> StatusLine cterm=NONE ctermfg=<span class="number">0</span> ctermbg=<span class="number">2</span></span><br><span class="line"><span class="keyword">highlight</span> StatusLineNc cterm=NONE ctermfg=<span class="number">0</span> ctermbg=<span class="number">7</span></span><br><span class="line"><span class="keyword">highlight</span> CgMf cterm=NONE ctermfg=<span class="number">0</span> ctermbg=<span class="number">3</span></span><br><span class="line"><span class="comment">" TabLine</span></span><br><span class="line"><span class="keyword">highlight</span> TabLineSel cterm=NONE ctermfg=<span class="number">0</span> ctermbg=<span class="number">2</span></span><br><span class="line"><span class="keyword">highlight</span> TabLine cterm=NONE ctermfg=<span class="number">0</span> ctermbg=<span class="number">7</span></span><br><span class="line"><span class="keyword">highlight</span> TabLineFill cterm=NONE ctermfg=<span class="number">0</span> ctermbg=<span class="number">7</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">" list of plugins</span></span><br><span class="line"><span class="comment">" ------------------------------------------------</span></span><br><span class="line"><span class="keyword">call</span> plug#begin(<span class="string">'~/.vim/plugged'</span>)</span><br><span class="line"><span class="comment">" basic</span></span><br><span class="line"><span class="comment">"</span></span><br><span class="line"><span class="comment">" 文件资源树</span></span><br><span class="line">Plug <span class="string">'scrooloose/nerdtree'</span></span><br><span class="line"><span class="comment">" 注释</span></span><br><span class="line">Plug <span class="string">'tpope/vim-commentary'</span></span><br><span class="line"><span class="comment">" 符号成对补全</span></span><br><span class="line">Plug <span class="string">'jiangmiao/auto-pairs'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" develop</span></span><br><span class="line"><span class="comment">"</span></span><br><span class="line"><span class="comment">" 文件git状态</span></span><br><span class="line">Plug <span class="string">'airblade/vim-gitgutter'</span></span><br><span class="line"><span class="comment">" html快速编写</span></span><br><span class="line">Plug <span class="string">'mattn/emmet-vim'</span></span><br><span class="line"><span class="comment">" js高亮及格式化</span></span><br><span class="line">Plug <span class="string">'pangloss/vim-javascript'</span></span><br><span class="line"><span class="keyword">call</span> plug#end()</span><br><span class="line"><span class="comment">" ------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" plugin options</span></span><br><span class="line"><span class="comment">" ------------------------------------------------</span></span><br><span class="line"><span class="comment">" scrooloose/nerdtree</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;F3&gt;</span> :NERDTreeToggle<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" airblade/vim-gitgutter</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:gitgutter_sign_removed_first_line</span> = <span class="string">'^'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">highlight</span> GitGutterAdd ctermfg=<span class="number">2</span></span><br><span class="line"><span class="keyword">highlight</span> GitGutterChange ctermfg=<span class="number">3</span></span><br><span class="line"><span class="keyword">highlight</span> GitGutterDelete ctermfg=<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Config </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python多线程同步测试</title>
      <link href="/2018-11/python-thread-test/"/>
      <url>/2018-11/python-thread-test/</url>
      
        <content type="html"><![CDATA[<p>一个python多线程的同步测试例子</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">var=<span class="string">""</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,id,name)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.id=id</span><br><span class="line">        self.name=name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#引用全局变量，使不同线程的变量作用域相同</span></span><br><span class="line">        <span class="keyword">global</span> var</span><br><span class="line">        print(<span class="string">'[begin: '</span>+self.name+<span class="string">']'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line"></span><br><span class="line">            <span class="comment">#获取锁</span></span><br><span class="line">            <span class="comment">#lock.acquire()</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment">#将当前的线程名赋值给var</span></span><br><span class="line">                var=<span class="string">'hello '</span>+self.name</span><br><span class="line"></span><br><span class="line">                <span class="comment">#增加时延，提高变量单位时间内被不同线程交叉修改的概率</span></span><br><span class="line">                time.sleep(<span class="number">0.1</span>)</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                <span class="string">'''</span></span><br><span class="line"><span class="string">                输出当前的线程id，和hell 线程名。目的是输出线程id与线程名是对应关系，</span></span><br><span class="line"><span class="string">                不过var可能会在本线程将内容输出的前被其他线程修改，</span></span><br><span class="line"><span class="string">                导致本线程最终输出的id和线程名不一致</span></span><br><span class="line"><span class="string">                '''</span></span><br><span class="line">                print(<span class="string">'id:'</span>+str(self.id)+<span class="string">'-&gt;'</span>+var)</span><br><span class="line"></span><br><span class="line">                <span class="comment">#释放锁</span></span><br><span class="line">                <span class="comment">#lock.release()</span></span><br><span class="line"></span><br><span class="line">        print(<span class="string">'[end: '</span>+self.name+<span class="string">']'</span>)</span><br><span class="line"></span><br><span class="line">th1=myThread(<span class="number">1</span>,<span class="string">'th1'</span>)</span><br><span class="line">th2=myThread(<span class="number">2</span>,<span class="string">'th2'</span>)</span><br><span class="line"></span><br><span class="line">th1.start()</span><br><span class="line">th2.start()</span><br><span class="line"></span><br><span class="line">th1.join()</span><br><span class="line">th2.join()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'[exit py]'</span>)</span><br></pre></td></tr></table></figure><p>在不开启线程锁时的执行结果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">root@unihon ~/py/threadtest # ./mythread.py</span><br><span class="line">[begin: th1]</span><br><span class="line">[begin: th2]</span><br><span class="line">id:1-&gt;hello th2</span><br><span class="line">id:2-&gt;hello th2</span><br><span class="line">id:2-&gt;hello th2</span><br><span class="line">id:1-&gt;hello th2</span><br><span class="line">id:1-&gt;hello th1</span><br><span class="line">id:2-&gt;hello th1</span><br><span class="line">id:1-&gt;hello th2</span><br><span class="line">id:2-&gt;hello th1</span><br><span class="line">id:1-&gt;hello th2</span><br><span class="line">id:2-&gt;hello th2</span><br><span class="line">id:1-&gt;hello th2</span><br><span class="line">id:2-&gt;hello th2</span><br><span class="line">id:1-&gt;hello th2</span><br><span class="line">id:2-&gt;hello th2</span><br><span class="line">id:1-&gt;hello th2</span><br><span class="line">id:2-&gt;hello th2</span><br><span class="line">id:1-&gt;hello th2</span><br><span class="line">[end: th1]</span><br><span class="line">id:2-&gt;hello th2</span><br><span class="line">[end: th2]</span><br><span class="line">[exit py]</span><br><span class="line">root@unihon ~/py/threadtest #</span><br></pre></td></tr></table></figure><p>可以看到，会有线程id和线程名不一致的情况。下面把脚本里的线程锁的注释取消，开启线程锁，再次执行脚本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">root@unihon ~/py/threadtest # ./mythread.py</span><br><span class="line">[begin: th1]</span><br><span class="line">[begin: th2]</span><br><span class="line">id:1-&gt;hello th1</span><br><span class="line">id:1-&gt;hello th1</span><br><span class="line">id:1-&gt;hello th1</span><br><span class="line">id:1-&gt;hello th1</span><br><span class="line">id:1-&gt;hello th1</span><br><span class="line">id:1-&gt;hello th1</span><br><span class="line">id:1-&gt;hello th1</span><br><span class="line">id:1-&gt;hello th1</span><br><span class="line">id:1-&gt;hello th1</span><br><span class="line">[end: th1]</span><br><span class="line">id:2-&gt;hello th2</span><br><span class="line">id:2-&gt;hello th2</span><br><span class="line">id:2-&gt;hello th2</span><br><span class="line">id:2-&gt;hello th2</span><br><span class="line">id:2-&gt;hello th2</span><br><span class="line">id:2-&gt;hello th2</span><br><span class="line">id:2-&gt;hello th2</span><br><span class="line">id:2-&gt;hello th2</span><br><span class="line">id:2-&gt;hello th2</span><br><span class="line">[end: th2]</span><br><span class="line">[exit py]</span><br></pre></td></tr></table></figure><p>这下，所有的线程id和线程名都准确的对应上了，目的达成。<br>注：这里整齐的线程分批输出，而不是各个线程混在一起，是因为循环太快了，在释放锁的瞬间又重新取得锁，以至于其他线程一直在等抢夺锁的机会。可以在循环开始时加个延时，减缓循环速度，就看到是各个线程混在一起输出了</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改bootstrap4的表单验证，使其支持ajax提交的表单</title>
      <link href="/2018-10/boot4-validation-customize/"/>
      <url>/2018-10/boot4-validation-customize/</url>
      
        <content type="html"><![CDATA[<p>bootstrap4表单验证的触发事件是表单的<code>submit</code>事件，如果用的ajax方式提交表单，显然是触发不了boot4的表单验证。因此对boot4的原码做些修改，使其验证支持<code>ajax</code>提交方式。</p><p><a href="https://getbootstrap.com/docs/4.0/components/forms/#validation" target="_blank" rel="noopener">bootstrap4官网表单验证版块</a></p><a id="more"></a><p><img src="/2018-10/boot4-validation-customize/201810071.png" alt>▲ 提交之前 </p><p><img src="/2018-10/boot4-validation-customize/201810072.png" alt>▲ 提交验证 </p><p>下面是官网的表单的触发代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">// Example starter JavaScript for disabling form submissions if there are invalid fields</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Fetch all the forms we want to apply custom Bootstrap validation styles to</span></span><br><span class="line">    <span class="keyword">var</span> forms = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'needs-validation'</span>);</span><br><span class="line">    <span class="comment">// Loop over them and prevent submission</span></span><br><span class="line">    <span class="keyword">var</span> validation = <span class="built_in">Array</span>.prototype.filter.call(forms, <span class="function"><span class="keyword">function</span>(<span class="params">form</span>) </span>&#123;</span><br><span class="line">      form.addEventListener(<span class="string">'submit'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (form.checkValidity() === <span class="literal">false</span>) &#123;</span><br><span class="line">          event.preventDefault();</span><br><span class="line">          event.stopPropagation();</span><br><span class="line">        &#125;</span><br><span class="line">        form.classList.add(<span class="string">'was-validated'</span>);</span><br><span class="line">      &#125;, <span class="literal">false</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, <span class="literal">false</span>);</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>分析，将关键的拿出来，下面是修改后：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> valiRes = <span class="string">""</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//$(.ifForm)是要验证的目标表单</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.filter.call($(<span class="string">'.ifForm'</span>), <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">valiRes = target.checkValidity();</span><br><span class="line">$(<span class="string">'.ifForm'</span>).addClass(<span class="string">'was-validated'</span>);</span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">//valiRes就是表单验证的结果，返回一个bool值</span></span><br><span class="line"><span class="keyword">if</span>(!valiRes)</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//表单验证未通过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//other...</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>核心代码就这些，可以加到<code>ajax</code>提交按钮的函数前面，判断是否要执行后续代码。</p><p><img src="/2018-10/boot4-validation-customize/201810073.gif" alt>▲ 效果（请忽略UI） </p><p>这段代码应该也适用于boot v4.1.x，之前看了下，两者变化不大。</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bootstrap4 </tag>
            
            <tag> validation </tag>
            
            <tag> ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记mariadb导入csv数据错位问题</title>
      <link href="/2018-10/db-value-question/"/>
      <url>/2018-10/db-value-question/</url>
      
        <content type="html"><![CDATA[<p>今早上将xlsx文件导出为csv文件，用sql导入到数据库中间遇到的一点问题。</p><a id="more"></a><p><img id="sm" src="/2018-10/db-value-question/201810041.png">▲ 结果如图</p><p>从这错乱可以直观的看出（打印内容过多也可能错乱），应该是哪里出问题了。表是自己设计的，可以排除不是编码和字段长度不够引起的。</p><p><img id="sm" src="/2018-10/db-value-question/201810042.png">▲ 查看id字段</p><p><img id="sm" src="/2018-10/db-value-question/201810043.png">▲ 查看speciality字段</p><p>从结果可以看出，问题应该在speciality字段上面。后面我接着重新导了一份csv数据，结果一样。着实是想不到问题出在哪里。疑问为什么id好好的，有中文那个字段就乱七八糟了，不应该是编码问题啊？接着尝试性的将表备份出来，看下。</p><p><img src="/2018-10/db-value-question/201810044.png" alt>▲ 查看备份数据</p><p>这下清楚了，每行数据后面多了<code>\r</code>，这个应该是windows下面的换行符。知道问题之后，就好解决了。</p><p><img id="sm" src="/2018-10/db-value-question/201810045.png">▲ 以二进制方式打开csv文件</p><p>可以看到<code>^M</code>结尾的换行符，这个就是要找要的<code>\r</code>，全部删除掉就好了，至于文件开头的<code>&lt;feff&gt;</code>说是<code>utf-8</code>标识相关的，先不理。</p><p><code>vim</code>下面有两个方法（可能还有其他的）批量把<code>\r</code>给删除掉，用的都是替换：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:%s/\r//g</span><br><span class="line">:%s/^M//g  #这里的^M不是直接打出来，用ctrl+v ctrl+m</span><br></pre></td></tr></table></figure><p>如果是对文件进行批量处理，可以将文件集中到一个目录下，接着用下面的命令：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls|xargs sed -i 's/\r//g'</span><br></pre></td></tr></table></figure><p><img id="sm" src="/2018-10/db-value-question/201810046.png">▲ 删除<code>\r</code>换行符后，重新导入</p><p>解决。</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> csv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>use wsl and frp build web server</title>
      <link href="/2018-09/wsl-frp-web/"/>
      <url>/2018-09/wsl-frp-web/</url>
      
        <content type="html"><![CDATA[<p>利用windows的linux子系统配合frp来搭建个人的网站服务器，利用这个wsl上面的服务器对个人的开发比较方便，方便恐怕是最直接的好处了吧，毕竟就是开启一个uwp应用一样的点一下…</p><p><strong>wsl和虚拟机相相比优势</strong></p><ul><li>安装方便：直接在windows store下载，不需要虚拟机</li><li>文件共享方便，电脑盘挂载在<code>/mnt/</code>目录下，虚拟机一般还要安装各种工具，如virtualbox</li><li>使用方便，打开uwp应用，或者在cmd、pw输入<code>wsl</code>命令</li></ul><p><strong>wsl和虚拟机相相比缺点</strong></p><ul><li>子系统功能还不完善，部分功能缺失，如<code>systemctl</code>等的命令还没支持</li></ul><h2 id="wsl基本安装步骤"><a href="#wsl基本安装步骤" class="headerlink" title="wsl基本安装步骤"></a>wsl基本安装步骤</h2><p><img id="sm" src="/2018-09/wsl-frp-web/set.png">▲ 开启子系统功能</p><p><img src="/2018-09/wsl-frp-web/store.png" alt>▲ windows store 上面的linux版本</p><p>以debian为例，安装完成之后，根据提示完成设置。输入<code>sudo passwd root</code>设置root的密码，<code>su -</code>切换root身份。<code>apt update</code>更新apt源（这里可以更改国内的apt源，应该会快点，配置文件是<code>/etc/apt/sources.list</code>），之后便可输入<code>apt install apache2</code>安装web服务器，对于其他软件同理。</p><p>因为<code>systemctl</code>不能用（在github上面看了下，应该是目前还没支持），所以得用<code>service</code>管理程序服务（个人之前一直是用centos，所以这个命令是基本没怎么用，突然感觉<code>systemctl</code>好方便(/▽＼)）。<br><code>service apache2 start</code>启动服务，对应<code>status</code>查看状态，<code>stop</code>停止服务。</p><p><img src="/2018-09/wsl-frp-web/bash.png" alt>▲ 启动apache</p><p>还有就是貌似<code>update-rc.d</code>这个命令控制的程序自启动没生效（有成功的可以call me），所以在家目录下的<code>.bashrc</code>文件下面加上下面这条命令来实现“程序自启动”。<br><code>echo &quot;your user passwd&quot;|sudo service apache2 start &gt;/dev/null 2&gt;&amp;1</code>(默认登录是linux向导里创建的那个用户)</p><p>这里的apache的配置文件是<code>apache2.conf</code>，和centos上面的<code>httpd.conf</code>有点不同，更改网站的根目录，是在<code>/etc/apache2/sites-available/000-default.conf</code>文件中配置。</p><p>在windows主机上面，浏览器打开<code>localhost</code>或者<code>本机ip</code>即可以访问。</p><p><img src="/2018-09/wsl-frp-web/showeb.png" alt>▲ 本地访问</p><h2 id="配合frp"><a href="#配合frp" class="headerlink" title="配合frp"></a>配合frp</h2><p>网上有比较多免费的frp服务器，同时也提供免费的域名，个人不时的用下足够了，嫌慢也可以在自己云服务器上面放一个。<br>这部分就不多说了，提供frp方的配置说明都很详细…</p><p><img src="/2018-09/wsl-frp-web/frpshow.png" alt>▲ 配合frp实现公网访问</p><p>此外可以利用<code>ssh</code>远程连接本地电脑的wsl，这间接的实现了远程管理本地电脑，因为电脑盘是挂载wsl上面的。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WSL </tag>
            
            <tag> frp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jd price tracking</title>
      <link href="/2018-08/jd-price-tracking/"/>
      <url>/2018-08/jd-price-tracking/</url>
      
        <content type="html"><![CDATA[<p>整理了下文件，看到一些以前弄的小东西，再拿来看下，也算是温习吧，不管什么，久了不用都很容易忘掉。<br>这个是用来跟踪商品价格的一个小爬虫，爬的是jd的数据，因为自己网购基本在那上面…</p><p>下面堆上代码。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#引入所需要的模块，现在应该基本都直接用requests了吧，</span></span><br><span class="line"><span class="comment">#不过一些教程还是会从自带的urllib开始讲</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#一个UA标识，证明下我是个人</span></span><br><span class="line">    <span class="comment">#因为不是高频爬虫，所以一个都够了，代理也免了</span></span><br><span class="line">    userAgent = <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#商品id</span></span><br><span class="line">    itemId = <span class="string">'7234518'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#jd的商品价格是动态生成的，直接加载的主页只有商品的名字什么的介绍，</span></span><br><span class="line">    <span class="comment">#所以F12把加载商品价格的文件找出来，分析下就行了</span></span><br><span class="line">    postUrl=<span class="string">"http://item.jd.com/"</span>+itemId+<span class="string">".html"</span></span><br><span class="line">    priceUrl=<span class="string">"http://p.3.cn/prices/mgets?skuIds=J_"</span>+itemId</span><br><span class="line"></span><br><span class="line">    header = &#123;</span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"userAgent"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#向服务器发送请求</span></span><br><span class="line">    resName = requests.get( postUrl , headers = header)</span><br><span class="line">    resPrice = requests.get( priceUrl , headers = header)</span><br><span class="line"></span><br><span class="line">    htName = resName.text</span><br><span class="line"></span><br><span class="line">    <span class="comment">#正则匹配商品名称</span></span><br><span class="line">    reName = re.search(<span class="string">'"sku-name"&gt;(.*?)&lt;/'</span>,htName,re.S) </span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">#group()提取的是正则匹配到的内容，group(n)则表示第n个捕获圆括号的内容，</span></span><br><span class="line">        <span class="comment">#如果group(x)，x又不存在则可能报错(AttributeError),</span></span><br><span class="line">        <span class="comment">#所以这里加个异常处理</span></span><br><span class="line">        name = reName.group(<span class="number">1</span>).strip()</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        print(<span class="string">"no have this item"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#对于服务器返回json数据，一般中文都是经过ASCII编码处理的，可以更好的传输，</span></span><br><span class="line">    <span class="comment">#json数据，可以用json模块的loads()函数处理</span></span><br><span class="line">    htPrice = json.loads(resPrice.text)</span><br><span class="line">    price = str(htPrice[<span class="number">0</span>][<span class="string">'p'</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">#time模块获取当时间</span></span><br><span class="line">    itime = time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>,time.localtime())</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'[time]\n'</span>)</span><br><span class="line">    print(itime)</span><br><span class="line">    print(<span class="string">'-------------------------------'</span>)</span><br><span class="line">    print(<span class="string">'[name]\n'</span>)</span><br><span class="line">    print(name)</span><br><span class="line">    print(<span class="string">'-------------------------------'</span>)</span><br><span class="line">    print(<span class="string">'[price]\n'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#判断是否有货，无货时，价格小于0（一般为-1）</span></span><br><span class="line">    <span class="keyword">if</span> float(price) &gt;= <span class="number">0</span>:</span><br><span class="line">        print(price)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"no stock"</span>)</span><br><span class="line">    print(<span class="string">'-------------------------------'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#文件名</span></span><br><span class="line">    fileN = <span class="string">'itemId_'</span>+itemId+<span class="string">'.txt'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#读取最近一次价格</span></span><br><span class="line">    <span class="comment">#os的popen()可以将shell执行的结果返回给变量，因为是对象数据，所以用read()读取</span></span><br><span class="line">    lastP = os.popen(<span class="string">"[ -f %s ] &amp;&amp; tail -n 1 %s|cut -d, -f1"</span>%(fileN,fileN)).read()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#与上一次记录的价格比较，自定义事件</span></span><br><span class="line">    <span class="keyword">if</span> lastP == price+<span class="string">'\n'</span>:</span><br><span class="line">        print(<span class="string">'is same'</span>)</span><br><span class="line">    <span class="keyword">elif</span> lastP != <span class="string">''</span>:</span><br><span class="line">        print(<span class="string">'is change'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#将价格,日期写入文件</span></span><br><span class="line">    <span class="comment">#with open ... as ...</span></span><br><span class="line">    <span class="comment">#这种写法的好处是不用再手动close文件</span></span><br><span class="line">    <span class="keyword">with</span> open(fileN,<span class="string">'a+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">     f.write(price+<span class="string">','</span>+itime+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#判断是否是直接执行脚本身，而非其他脚本调用</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(<span class="string">"==============================="</span>)</span><br><span class="line">    fun()</span><br><span class="line">    print(<span class="string">"==============================="</span>)</span><br></pre></td></tr></table></figure><p>看下运行效果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost xjd]#./xjd.py </span><br><span class="line">===============================</span><br><span class="line">[time]</span><br><span class="line"></span><br><span class="line">2018-08-19 23:30:07</span><br><span class="line">-------------------------------</span><br><span class="line">[name]</span><br><span class="line"></span><br><span class="line">三星(SAMSUNG) 970 EVO 500G M.2 NVMe 固态硬盘（MZ-V7E500BW）</span><br><span class="line">-------------------------------</span><br><span class="line">[price]</span><br><span class="line"></span><br><span class="line">1299.00</span><br><span class="line">-------------------------------</span><br><span class="line">is same</span><br><span class="line">===============================</span><br><span class="line">[root@localhost xjd]# cat itemId_7234518.txt </span><br><span class="line">1299.00,2018-08-19 22:07:39</span><br><span class="line">1299.00,2018-08-19 23:30:07</span><br><span class="line">[root@localhost xjd]#</span><br></pre></td></tr></table></figure><p>对于jd那个商品id，应该是比较固定的，这是长期跟踪价格的基础。<br>最后可以用crontab定期运行脚本。</p><hr><p>文件链接：<a href="https://github.com/unihon/python_uni/tree/master/xjd" target="_blank" rel="noopener">xjd.py</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web-spider </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>about me</title>
      <link href="/2018-08/about-me/"/>
      <url>/2018-08/about-me/</url>
      
        <content type="html"><![CDATA[<p>最终选了hexo做长更站…<br>就是想静点…</p><p>其实最先接触到的静态网站引擎是github推荐的jekyll。github page后台可以直接将jekyll原始文件转换为静态网页，这点要比hexo方便。因为hexo每次推文都得在本地手动将原始文件转换，然后再push到仓库（借助Travis CI之类工具可以简化此流程）。<a id="more"></a></p><p>回头看下之前自己建的站，想想当初自己真是“坚强”，应该除了富文本编辑器之外，所有东西都是自己一键一键码出来了吧…基本都自己“瞎想”、coding去实现的，现在看来不管是管理还是拓展性，都非常弱额…因为没有用框架（用了jq），所以代码相比一些“工厂式的标准”也是稀巴烂(想象下超大串的js字符串拼接)…</p><p><img src="/2018-08/about-me/web.png" alt>▲ 桌面端</p><p><img src="/2018-08/about-me/mweb.jpg" alt>▲ 小屏端</p><p>以前比较热衷于自己coding去实现想要的功能，其实就是想自己能实现的，就自己coding吧。比较花时间，不过自己也接触了不少东西，虽然这可能不是我今后所要深入的。</p><p>后面接触了各种的框架、css库，thinkphp、laravel、vue等。发现同样的功能，原来这么“简单几行”就实现了我当初煞费苦心coding的代码（当然也需要学习成本），内心的感受是~~  </p><p><img src="/2018-08/about-me/page.png" alt>▲ 写分页的构思（局部）</p><p>现在没了当初有种遇到什么都想去尝试下的“冲劲”，感觉时间耗不起还是什么，也没了那种精力，可能是懒吧？哈哈~~不过最重要的还是要明白自己真正要的是什么。</p><p>我只想专心于本应该要做的事情上面。</p><hr><p><strong>博客相关：</strong></p><ul><li>博客就不开留言了，也不怎么想管理，有问题可以用E-mail联系我</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> about </tag>
            
            <tag> unihon </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
